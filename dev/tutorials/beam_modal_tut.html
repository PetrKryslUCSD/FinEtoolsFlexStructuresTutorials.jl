<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modal analysis of simply supported/clamped beam · FinEtoolsFlexStructuresTutorials.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">FinEtoolsFlexStructuresTutorials.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="beam_modal_tut.html">Modal analysis of simply supported/clamped beam</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="beam_modal_tut.html">Modal analysis of simply supported/clamped beam</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtoolsFlexStructuresTutorials.jl/blob/master/docs/src/tutorials/beam_modal_tut.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modal-analysis-of-simply-supported/clamped-beam"><a class="docs-heading-anchor" href="#Modal-analysis-of-simply-supported/clamped-beam">Modal analysis of simply supported/clamped beam</a><a id="Modal-analysis-of-simply-supported/clamped-beam-1"></a><a class="docs-heading-anchor-permalink" href="#Modal-analysis-of-simply-supported/clamped-beam" title="Permalink"></a></h1><p>Source code: <a href="beam_modal_tut.jl"><code>beam_modal_tut.jl</code></a></p><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>Vibration analysis of a beam simply supported in one plane, and clamped in another. The results are compared with analytical expressions.</p><h2 id="Goals"><a class="docs-heading-anchor" href="#Goals">Goals</a><a id="Goals-1"></a><a class="docs-heading-anchor-permalink" href="#Goals" title="Permalink"></a></h2><ul><li>Introduce definition of cross-section.</li><li>Show generation of finite element mesh of beams.</li><li>Describe geometry, displacement, and rotation fields.</li><li>Describe application of support conditions.</li><li>Calculate the discrete model quantities and solve the free vibration problem.</li><li>Demonstrate visualization of the free vibrations.</li></ul><h2 id="Definition-of-the-basic-inputs"><a class="docs-heading-anchor" href="#Definition-of-the-basic-inputs">Definition of the basic inputs</a><a id="Definition-of-the-basic-inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-basic-inputs" title="Permalink"></a></h2><p>We will probably need some linear algebra functions.</p><pre><code class="language-julia hljs">using LinearAlgebra</code></pre><p>The finite element code relies on the basic functionality implemented in this package.</p><pre><code class="language-julia hljs">using FinEtools</code></pre><p>The material parameters may be defined with the specification of the units. The elastic properties are:</p><pre><code class="language-julia hljs">E = 30002.0 * phun(&quot;ksi&quot;)
nu = 0.0;</code></pre><p>The mass density is expressed in customary units as</p><pre><code class="language-julia hljs">rho = 0.28 * phun(&quot;lbm/in^3&quot;)</code></pre><p>Here are the cross-sectional dimensions and the length of the beam between supports.</p><pre><code class="language-julia hljs">b = 1.8 * phun(&quot;in&quot;); h = 1.8 * phun(&quot;in&quot;); L = 100 * phun(&quot;in&quot;);</code></pre><h2 id="Analytical-frequencies"><a class="docs-heading-anchor" href="#Analytical-frequencies">Analytical frequencies</a><a id="Analytical-frequencies-1"></a><a class="docs-heading-anchor-permalink" href="#Analytical-frequencies" title="Permalink"></a></h2><p>The analytical frequencies were taken from table 8-1 of Formulas for natural frequency and mode shape, Robert D. Blevins, Krieger publishing company, Malabar Florida, reprint edition 2001. Available also in FORMULAS FOR DYNAMICS, ACOUSTICS AND VIBRATION, by the same author, Wiley, 2016, Table 4.2.</p><p>The beam is aligned with the <span>$Y$</span> global Cartesian coordinate. The beam behaves as a simply supported beam in the vertical plane (global Cartesian <span>$YZ$</span>), while in the horizontal plane (global Cartesian <span>$XY$</span>) it behaves as a clamped beam.</p><p>The cross-sectional properties are:</p><pre><code class="language-julia hljs">A = b * h;
I2 = b * h^3 / 12;
I3 = b^3 * h / 12;</code></pre><p>Then the analytical vibration frequencies for the first two modes are:</p><pre><code class="language-julia hljs">@show analyt_freq = [(1 * pi)^2, (4.73004074)^2] .* (sqrt(E * I2 / rho / A) / (2 * pi * L^2));</code></pre><p>The purpose of the numerical model is to calculate approximation to these two analytical natural frequencies.</p><pre><code class="language-julia hljs">neigvs = length(analyt_freq);</code></pre><h2 id="Cross-section"><a class="docs-heading-anchor" href="#Cross-section">Cross-section</a><a id="Cross-section-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-section" title="Permalink"></a></h2><p>Cross-sectional properties are incorporated in the cross-section object. The three arguments supplied are functions. All are returning &quot;constants&quot;, as appropriate for a uniform cross section beam. In particular the first two functions each return the dimension of the cross-section as a constant; the third function defines the orientation of the cross-section in the global Cartesian coordinates. <code>[1.0, 0.0, 0.0]</code> is the vector that together with the tangent to the midline curve of the beam spans the <span>$x_1x_2$</span> plane of the local coordinates for the beam.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.CrossSectionModule: CrossSectionRectangle
cs = CrossSectionRectangle(s -&gt; b, s -&gt; h, s -&gt; [1.0, 0.0, 0.0])</code></pre><p>We can compare the analytical values of the cross-section properties with those stored in the <code>cs</code> structure:</p><pre><code class="language-julia hljs">@show A, I2, I3
@show cs.parameters(0.0)</code></pre><h2 id="Mesh-generation"><a class="docs-heading-anchor" href="#Mesh-generation">Mesh generation</a><a id="Mesh-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-generation" title="Permalink"></a></h2><p>Now we generate the mesh of the beam. The locations of its two endpoints are:</p><pre><code class="language-julia hljs">xyz = [[0 -L / 2 0]; [0 L / 2 0]]</code></pre><p>We will generate</p><pre><code class="language-julia hljs">n = 4</code></pre><p>beam elements along the member.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.MeshFrameMemberModule: frame_member
fens, fes = frame_member(xyz, n, cs);</code></pre><p>The mesh definition consists of the nodes</p><pre><code class="language-julia hljs">@show fens</code></pre><p>and the finite elements</p><pre><code class="language-julia hljs">@show fes</code></pre><p>Note  that the cross-sectional properties are incorporated through <code>cs</code>.</p><h2 id="Material"><a class="docs-heading-anchor" href="#Material">Material</a><a id="Material-1"></a><a class="docs-heading-anchor-permalink" href="#Material" title="Permalink"></a></h2><p>Material properties can be now used to create a material: isotropic elasticity model of the <code>FinEtoolsDeforLinear</code> package is instantiated.</p><pre><code class="language-julia hljs">using FinEtoolsDeforLinear
material = MatDeforElastIso(DeforModelRed3D, rho, E, nu, 0.0)</code></pre><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><p>Now we start constructing the discrete finite element model. We begin by constructing the requisite fields, geometry and displacement. These are the so-called &quot;configuration variables&quot;, all initialized to zero.</p><p>This is the geometry field. It describes the locations of the nodes.</p><pre><code class="language-julia hljs">geom0 = NodalField(fens.xyz)</code></pre><p>This is the displacement field, three unknown displacements per node.</p><pre><code class="language-julia hljs">u0 = NodalField(zeros(size(fens.xyz, 1), 3))</code></pre><p>This is the rotation (orientation) field, where the three unknown rotations per node are represented with a rotation matrix, in total nine numbers. The utility function <code>initial_Rfield</code> is used to construct this initial orientation field where each orientation matrix is the identity.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.RotUtilModule: initial_Rfield
Rfield0 = initial_Rfield(fens)</code></pre><p>Here we verify the number of nodes and the number of degrees of freedom in the rotation field per node.</p><pre><code class="language-julia hljs">@show nents(Rfield0)
@show ndofs(Rfield0)</code></pre><p>Finally, this is the displacement and rotation field for incremental changes, incremental displacements and incremental rotations. In total, 6 unknowns per node.</p><pre><code class="language-julia hljs">dchi = NodalField(zeros(size(fens.xyz, 1), 6))</code></pre><h2 id="Support-conditions"><a class="docs-heading-anchor" href="#Support-conditions">Support conditions</a><a id="Support-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Support-conditions" title="Permalink"></a></h2><p>Now we apply the essential boundary conditions (EBCs) to enforce the action of the supports at the ends of the beam.</p><p>First we select the node at the location  <code>[0 -L/2 0]</code>. We do that by searching for all nodes that are located inside a tiny box centered at this location. The tolerance of a fraction of the length of an element (i. e. the distance between the nodes) is used to take the location and blow it up into a nonzero-volume box.</p><pre><code class="language-julia hljs">l1 = selectnode(fens; box=[0 0 -L / 2 -L / 2 0 0], tolerance=L / n / 1000)</code></pre><p>The nodes in this list should consist of a single node (which is why the tolerance is so small, in order to limit the selection to a single node near the location given).</p><pre><code class="language-julia hljs">@show length(l1) == 1</code></pre><p>The boundary condition at this point dictates zero displacements (degrees of freedom 1, 2, and 3) and zero rotations about <span>$Y$</span> (5) and <span>$Z$</span> (6). This leaves rotation about the <span>$X$</span> free.</p><pre><code class="language-julia hljs">for i in [1,2,3,5,6]
    setebc!(dchi, l1, true, i)
end</code></pre><p>Similarly, the node next to the other end of the beam is selected.</p><pre><code class="language-julia hljs">l1 = selectnode(fens; box=[0 0 L / 2  L / 2 0 0], tolerance=L / n / 1000)</code></pre><p>And an identical boundary condition combination is enforced.</p><pre><code class="language-julia hljs">for i in [1,2,3,5,6]
    setebc!(dchi, l1, true, i)
end</code></pre><p>These boundary conditions now need to be &quot;applied&quot;. This simply means that the prescribed values of the degrees of freedom are copied into the active degrees of freedom.</p><pre><code class="language-julia hljs">applyebc!(dchi)</code></pre><p>The essential boundary conditions will also reduce the number of free (unknown) degrees of freedom.</p><pre><code class="language-julia hljs">numberdofs!(dchi);</code></pre><p>Here we inspect the degrees of freedom in the incremental displacement/rotation field:</p><pre><code class="language-julia hljs">@show dchi.dofnums</code></pre><p>Note that the degrees of freedom are actually carried by the incremental field, not by the displacement or the rotation fields. There are therefore 6 degrees of freedom per node in the incremental displacement field.</p><h2 id="Assemble-the-global-discrete-system"><a class="docs-heading-anchor" href="#Assemble-the-global-discrete-system">Assemble the global discrete system</a><a id="Assemble-the-global-discrete-system-1"></a><a class="docs-heading-anchor-permalink" href="#Assemble-the-global-discrete-system" title="Permalink"></a></h2><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.FEMMCorotBeamModule: FEMMCorotBeam
femm = FEMMCorotBeam(IntegDomain(fes, GaussRule(1, 2)), material);</code></pre><p>For disambiguation we will refer to the stiffness and mass functions by qualifying them with the corotational-beam module, <code>FEMMCorotBeamModule</code>. We will use the abbreviation <code>CB</code>.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.FEMMCorotBeamModule
CB = FEMMCorotBeamModule</code></pre><p>Thus we can construct the stiffness and mass matrix as follows: Note that the finite element machine is the first argument. This provides access to the integration domain. The next argument is the geometry field, followed by the displacement, rotations, and incremental displacement/rotation fields.</p><pre><code class="language-julia hljs">K = CB.stiffness(femm, geom0, u0, Rfield0, dchi);
M = CB.mass(femm, geom0, u0, Rfield0, dchi);</code></pre><p>We can compare the size of the stiffness matrix with the number of degrees of freedom that are unknown (20).</p><pre><code class="language-julia hljs">@show size(K)</code></pre><h2 id="Solve-the-free-vibration-problem"><a class="docs-heading-anchor" href="#Solve-the-free-vibration-problem">Solve the free-vibration problem</a><a id="Solve-the-free-vibration-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-free-vibration-problem" title="Permalink"></a></h2><p>The Arnoldi algorithm implemented in the well-known <code>Arpack</code> package is used to solve the generalized eigenvalue problem with the sparse matrices. As is common in structural dynamics, we request the smallest eigenvalues in absolute value (<code>:SM</code>). In order to help the function decide which algorithm is suitable, we explicitly designate the matrices as symmetric.</p><pre><code class="language-julia hljs">using Arpack
evals, evecs, nconv = eigs(Symmetric(K), Symmetric(M); nev=neigvs, which=:SM, explicittransform = :none);</code></pre><p>We should check that the requested eigenvalues actually converged:</p><pre><code class="language-julia hljs">@show nconv == neigvs</code></pre><p>The eigenvalues (i. e. the squares of the angular frequencies) are returned in the vector <code>evals</code>. The mode shapes constitute the columns of the matrix <code>evecs</code>.</p><pre><code class="language-julia hljs">@show size(evecs)</code></pre><p>The natural frequencies are obtained from the squares of the angular frequencies. We note the use of <code>sqrt.</code> which broadcasts the square root over the array <code>evals</code>.</p><pre><code class="language-julia hljs">fs = sqrt.(evals) / (2 * pi);</code></pre><h2 id="Comparison-of-computed-and-analytical-results"><a class="docs-heading-anchor" href="#Comparison-of-computed-and-analytical-results">Comparison of computed and analytical results</a><a id="Comparison-of-computed-and-analytical-results-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-computed-and-analytical-results" title="Permalink"></a></h2><p>The approximate and analytical frequencies are now reported.</p><pre><code class="language-julia hljs">println(&quot;Approximate frequencies: $fs [Hz]&quot;)
println(&quot;Analytical frequencies: $analyt_freq [Hz]&quot;)</code></pre><p>Close agreement between the approximate and analytical frequencies can be observed: The error of the numerical solution is a fraction of a percent.</p><pre><code class="language-julia hljs">errs = abs.(analyt_freq .- fs) ./ analyt_freq
println(&quot;Relative errors of frequencies: $errs [ND]&quot;)</code></pre><h2 id="Visualize-vibration-modes"><a class="docs-heading-anchor" href="#Visualize-vibration-modes">Visualize vibration modes</a><a id="Visualize-vibration-modes-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-vibration-modes" title="Permalink"></a></h2><p>The animation will show one of the vibration modes overlaid on the undeformed geometry.</p><p>The visualization utilities take advantage of the PlotlyJS library.</p><pre><code class="language-julia hljs">using VisualStructures: plot_space_box, plot_solid, render, react!, default_layout_3d, save_to_json</code></pre><p>The configuration during the animation needs to reflect rotations. The function <code>update_rotation_field!</code> will update the rotation field given a vibration mode.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.RotUtilModule: update_rotation_field!</code></pre><p>The magnitude of the vibration modes (displacements  and rotations) will be amplified with this scale factor:</p><pre><code class="language-julia hljs">scale = 1.2</code></pre><p>This is the mode that will be animated:</p><pre><code class="language-julia hljs">mode = 1</code></pre><p>In order to handle variables inside loops correctly, we create a local scope with the <code>let end</code> block.</p><pre><code class="language-julia hljs">let</code></pre><p>The extents of the box will be preserved during animation in order to eliminate changes in the viewing parameters.</p><pre><code class="language-julia hljs">    tbox = plot_space_box([[-0.2 * L -L / 2 -0.2 * L]; [+0.2 * L L / 2 +0.2 * L]])</code></pre><p>This is the geometry of the structure without deformation (undeformed). It is displayed as gray, partially transparent.</p><pre><code class="language-julia hljs">    tenv0 = plot_solid(fens, fes; x=geom0.values, u=0.0 .* dchi.values[:, 1:3], R=Rfield0.values, facecolor=&quot;rgb(125, 155, 125)&quot;, opacity=0.3);</code></pre><p>Initially the plot consists of the box and the undeformed geometry.</p><pre><code class="language-julia hljs">    plots = cat(tbox, tenv0; dims=1)</code></pre><p>Create the layout for the plot. Set the size of the window.</p><pre><code class="language-julia hljs">    layout = default_layout_3d(; options = Dict(:responsive=&gt;true))</code></pre><p>Set the aspect mode to get the correct proportions.</p><pre><code class="language-julia hljs">    layout[:scene][:aspectmode] = &quot;data&quot;</code></pre><p>Render the undeformed structure</p><pre><code class="language-julia hljs">    pl = render(plots; layout=layout, title=&quot;Mode $(mode)&quot;)
    sleep(2.115)</code></pre><p>This is the animation loop.</p><ul><li>Distribute a fraction of the selected eigenvector into the incremental displacement/rotation field.</li><li>Create the deformed configuration by defining displacement field <code>u1</code> and rotation field <code>Rfield1</code>.</li><li>Create the plot for the deformed configuration, and add it to the list of plots.</li><li>Call the <code>react!</code> function to update the display. Sleep for a brief period of time to give the display a chance to become current.</li></ul><pre><code class="language-julia hljs">    for xscale in scale .* sin.(collect(0:1:89) .* (2 * pi / 21))
        scattersysvec!(dchi, xscale .* evecs[:, mode])
        u1 = deepcopy(u0)
        u1.values .= dchi.values[:, 1:3]
        Rfield1 = deepcopy(Rfield0)
        update_rotation_field!(Rfield1, dchi)
        tenv1 = plot_solid(fens, fes; x=geom0.values, u=dchi.values[:, 1:3], R=Rfield1.values, facecolor=&quot;rgb(50, 55, 125)&quot;);
        plots = cat(tbox, tenv0, tenv1; dims=1)
        react!(pl, plots, pl.plot.layout)
        sleep(0.115)
    end</code></pre><p>Save the plot to a Json file. It can be then re-displayed later.</p><pre><code class="language-julia hljs">    save_to_json(pl, &quot;deformed_plot.json&quot;)
end</code></pre><p>Load the plot from a file.</p><pre><code class="language-julia hljs">using VisualStructures: plot_from_json
plot_from_json(&quot;deformed_plot.json&quot;)</code></pre><p>Nothing to return.</p><pre><code class="language-julia hljs">nothing</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 14 January 2022 04:13">Friday 14 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
