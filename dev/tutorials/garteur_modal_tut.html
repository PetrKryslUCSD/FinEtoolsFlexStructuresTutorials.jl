<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GARTEUR SM-AG19 Testbed: Modal analysis · FinEtoolsFlexStructuresTutorials.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">FinEtoolsFlexStructuresTutorials.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="garteur_modal_tut.html">GARTEUR SM-AG19 Testbed: Modal analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="garteur_modal_tut.html">GARTEUR SM-AG19 Testbed: Modal analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtoolsFlexStructuresTutorials.jl/blob/master/docs/src/tutorials/garteur_modal_tut.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GARTEUR-SM-AG19-Testbed:-Modal-analysis"><a class="docs-heading-anchor" href="#GARTEUR-SM-AG19-Testbed:-Modal-analysis">GARTEUR SM-AG19 Testbed: Modal analysis</a><a id="GARTEUR-SM-AG19-Testbed:-Modal-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#GARTEUR-SM-AG19-Testbed:-Modal-analysis" title="Permalink"></a></h1><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>This virtual test application is based on the test article used by the GARTEUR Structures &amp; Materials Action Group 19 which organized a Round Robin exercise where 12 European laboratories tested a single structure between 1995 and 1997. The benchmark structure was a laboratory structure built to simulate the dynamic behaviour of an aeroplane. The structure was initially built for a benchmark study on experimental modal analysis conducted by the Structures and Materials Action Group (SM-AG19) of the Group for Aeronautical Research and Technology in EURope (GARTEUR). The test-bed was designed and manufactured by ONERA, France.</p><p><img src="IMAC97photo.png" alt/></p><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><ul><li>[GARTEUR] Ground Vibration Test Techniques, compiled by A Gravelle, GARTEUR Structures &amp; Materials Action Group 19 Technical report TP-115, 1999.</li><li>[BW] Etienne Balmes, Jan R. Wright, GARTEUR GROUP ON GROUND VIBRATION TESTING | RESULTS FROM THE TEST OF A SINGLE STRUCTURE BY 12 LABORATORIES IN EUROPE, Proceedings of DETC&#39;97, 1997 ASME Design Engineering Technical Conferences, September 14-17, 1997, Sacramento, California.</li><li>[3M] 3M(TM) Viscoelastic Damping Polymer 112 Series,  Technical Data, May 2017.</li></ul><h2 id="Goals"><a class="docs-heading-anchor" href="#Goals">Goals</a><a id="Goals-1"></a><a class="docs-heading-anchor-permalink" href="#Goals" title="Permalink"></a></h2><ul><li>Show how to construct model from multiple connected beams.</li><li>Demonstrate the use of massless connectors.</li><li>Demonstrate the use of point masses.</li><li>Demonstrate the use of grounded springs.</li><li>Illustrate verification of the solution of the free vibration problem.</li></ul><pre><code class="language-julia hljs">#</code></pre><h2 id="Geometry-of-the-testbed-airplane."><a class="docs-heading-anchor" href="#Geometry-of-the-testbed-airplane.">Geometry of the testbed airplane.</a><a id="Geometry-of-the-testbed-airplane.-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-of-the-testbed-airplane." title="Permalink"></a></h2><p>The aluminum testbed was a rather simple structure which was reasonably dynamically representative of a simple airplane structure <a href="tutorials/@ref References">GARTEUR</a>. It was composed of several beams simulating a fuselage with wings and a tail. Wing tip drums allowed to adjust bending and torsion frequencies similarly to airplane ones, with some very close modal frequencies.</p><p><img src="garteur-geom.png" alt/></p><p>The script included below defines the geometry of the structure, the cross-sectional properties, the connectivity, and the location of the nodes.</p><pre><code class="language-julia hljs">include(&quot;garteur_geometry_tut.jl&quot;)</code></pre><p>The geometry is visualized in the tutorial <a href="garteur_geometry_vis_tut.jl"><code>garteur_geometry_vis_tut.md</code></a>.</p><pre><code class="language-julia hljs">#</code></pre><h2 id="Material"><a class="docs-heading-anchor" href="#Material">Material</a><a id="Material-1"></a><a class="docs-heading-anchor-permalink" href="#Material" title="Permalink"></a></h2><p>Material properties can be now used to create a material: isotropic elasticity model of the <code>FinEtoolsDeforLinear</code> package is instantiated.</p><pre><code class="language-julia hljs">using FinEtoolsDeforLinear</code></pre><p>The material of the structure is aluminum. The elastic modulus:</p><pre><code class="language-julia hljs">E = 70000.0 * phun(&quot;MPa&quot;)
nu = 0.31;</code></pre><p>The mass density:</p><pre><code class="language-julia hljs">rho = 2700 * phun(&quot;kg/m^3&quot;)
alu = MatDeforElastIso(DeforModelRed3D, rho, E, nu, 0.0)</code></pre><p>The material of the constraining layer on top of the viscoelastic tape. It was aluminum.</p><pre><code class="language-julia hljs">layer = MatDeforElastIso(DeforModelRed3D, rho, alu.E, alu.nu, 0.0)</code></pre><p>Material for the massless connectors has the mass density set to zero; otherwise it has the same properties as the aluminum material  of the structure.</p><pre><code class="language-julia hljs">massless = MatDeforElastIso(DeforModelRed3D, 0.0, alu.E, alu.nu, 0.0)</code></pre><p>This simple function returns material based on the label of the beam elements.</p><pre><code class="language-julia hljs">getmaterial(labl) = begin
    if labl == 6
        return layer
    elseif labl == 7 || labl == 8
        return massless
    end
    return alu
end</code></pre><p>This is the assumed stifffness of the bungee cords (each one separately).</p><pre><code class="language-julia hljs">bungeecoefficient = 4000*phun(&quot;N/m&quot;);


#</code></pre><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><p>Now we start constructing the discrete finite element model. We begin by constructing the requisite fields, geometry and displacement. These are the so-called &quot;configuration variables&quot;, all initialized to 0. This is that geometry field.</p><pre><code class="language-julia hljs">geom0 = NodalField(fens.xyz)</code></pre><p>This is the displacement field, three unknown displacements per node.</p><pre><code class="language-julia hljs">u0 = NodalField(zeros(size(fens.xyz, 1), 3))</code></pre><p>This is the rotation field, three unknown rotations per node are represented with a rotation matrix, in total nine numbers. The utility function <code>initial_Rfield</code></p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.RotUtilModule: initial_Rfield
Rfield0 = initial_Rfield(fens)</code></pre><p>Finally, this is the displacement and rotation field for incremental changes, incremental displacements and incremental rotations. In total, 6 unknowns per node.</p><pre><code class="language-julia hljs">dchi = NodalField(zeros(size(fens.xyz, 1), 6))</code></pre><p>There are no support conditions.</p><pre><code class="language-julia hljs">applyebc!(dchi)</code></pre><p>The  the number of free(unknown) degrees of freedom is equal to the total number of degrees of freedom in the system.</p><pre><code class="language-julia hljs">numberdofs!(dchi);

#</code></pre><h2 id="Identify-support-points-and-locations-of-sensors"><a class="docs-heading-anchor" href="#Identify-support-points-and-locations-of-sensors">Identify support points and locations of sensors</a><a id="Identify-support-points-and-locations-of-sensors-1"></a><a class="docs-heading-anchor-permalink" href="#Identify-support-points-and-locations-of-sensors" title="Permalink"></a></h2><p>Suspension points</p><pre><code class="language-julia hljs">suspln = selectnode(fens; box = initbox!(Float64[], vec([0.0*L 0.0*L 0.805*L])), inflate = tolerance)
susprn = selectnode(fens; box = initbox!(Float64[], vec([0.0*L -0.0*L 0.805*L])), inflate = tolerance)
suspbn = selectnode(fens; box = initbox!(Float64[], vec([-2.0*L 0.0*L 0.0*L])), inflate = tolerance)</code></pre><p>The sensors at the tip of the left and right wing drum</p><pre><code class="language-julia hljs">sensor112n = selectnode(fens; box = initbox!(Float64[], vec([+1.8*L 9.8*L 0.96*L])), inflate = tolerance)
sensor12n = selectnode(fens; box = initbox!(Float64[], vec([+1.8*L -9.8*L .96*L])), inflate = tolerance)
sensor111n = selectnode(fens; box = initbox!(Float64[], vec([-1.8*L 9.8*L 0.96*L])), inflate = tolerance)
sensor11n = selectnode(fens; box = initbox!(Float64[], vec([-1.8*L -9.8*L .96*L])), inflate = tolerance)</code></pre><p>The joint between the horizontal and vertical tail parts</p><pre><code class="language-julia hljs">sensor202n = selectnode(fens; box = initbox!(Float64[], vec([-8*L 0 3.8*L])), inflate = tolerance)

#</code></pre><h2 id="Assemble-the-global-discrete-system"><a class="docs-heading-anchor" href="#Assemble-the-global-discrete-system">Assemble the global discrete system</a><a id="Assemble-the-global-discrete-system-1"></a><a class="docs-heading-anchor-permalink" href="#Assemble-the-global-discrete-system" title="Permalink"></a></h2><p>For disambiguation we will refer to the stiffness and mass functions by qualifying them with the corotational-beam module, <code>FEMMCorotBeamModule</code>.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.FEMMCorotBeamModule
CB = FEMMCorotBeamModule</code></pre><p>Note that we have an array of finite element sets. We compute the matrices for each set separately and accumulate them into the final overall matrix. Thus we can construct the stiffness and mass matrix as follows.</p><pre><code class="language-julia hljs">using  SparseArrays

K, M = let
    K = spzeros(dchi.nfreedofs, dchi.nfreedofs)
    M = spzeros(dchi.nfreedofs, dchi.nfreedofs)
    for fes in fesa
        labl  = fes.label[1]
        femm = CB.FEMMCorotBeam(IntegDomain(fes, GaussRule(1, 2)), getmaterial(labl));
        K += CB.stiffness(femm, geom0, u0, Rfield0, dchi);
        M += CB.mass(femm, geom0, u0, Rfield0, dchi);
    end
    K, M
end

#</code></pre><h2 id="Additional-concentrated-masses."><a class="docs-heading-anchor" href="#Additional-concentrated-masses.">Additional concentrated masses.</a><a id="Additional-concentrated-masses.-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-concentrated-masses." title="Permalink"></a></h2><pre><code class="language-julia hljs">using LinearAlgebra

using FinEtoolsFlexStructures.FEMMPointMassModule
PM = FEMMPointMassModule</code></pre><p>There is at the sensor on the tail.</p><pre><code class="language-julia hljs">femmcm1 =  PM.FEMMPointMass(IntegDomain(FESetP1(reshape([sensor202n;], 1, 1)), PointRule()), FFltMat(2*L*L/5*L/5*2*rho*LinearAlgebra.I(3)));</code></pre><p>These are the forward/interior locations on the wing drums.</p><pre><code class="language-julia hljs">mass1n = selectnode(fens; box = initbox!(Float64[], vec([1.8*L 9.2*L .96*L])), inflate = tolerance)
mass2n = selectnode(fens; box = initbox!(Float64[], vec([1.8*L -9.2*L .96*L])), inflate = tolerance)
femmcm2 =  PM.FEMMPointMass(IntegDomain(FESetP1(reshape([mass1n; mass2n;], 2, 1)), PointRule()), FFltMat(0.2*phun(&quot;kg&quot;)*LinearAlgebra.I(3)));

Mp = PM.mass(femmcm1, geom0, u0, Rfield0, dchi) + PM.mass(femmcm2, geom0, u0, Rfield0, dchi);

#</code></pre><h2 id="Bungee-supports"><a class="docs-heading-anchor" href="#Bungee-supports">Bungee supports</a><a id="Bungee-supports-1"></a><a class="docs-heading-anchor-permalink" href="#Bungee-supports" title="Permalink"></a></h2><pre><code class="language-julia hljs">using LinearAlgebra

using FinEtoolsFlexStructures.FEMMPointGroundedSpringModule
BS = FEMMPointGroundedSpringModule</code></pre><p>There are three suspension points at the top of the fuselage. We assume that these bungee supports exert only reaction in the vertical direction.</p><pre><code class="language-julia hljs">femmbs =  BS.FEMMPointGroundedSpring(IntegDomain(FESetP1(reshape([suspln; susprn; suspbn;], 3, 1)), PointRule()),
FFltMat([bungeecoefficient*[0;0;1]*[0;0;1]&#39; 0*LinearAlgebra.I(3); 0*LinearAlgebra.I(3) 0*LinearAlgebra.I(3)]));

Kb = BS.stiffness(femmbs, geom0, u0, Rfield0, dchi)

Kt = K + Kb
Mt = M + Mp</code></pre><p>We can compare the size of the stiffness matrix with the number of degrees of freedom that are unknown (20).</p><pre><code class="language-julia hljs">@show size(Kt)

#</code></pre><h2 id="Solve-the-free-vibration-problem"><a class="docs-heading-anchor" href="#Solve-the-free-vibration-problem">Solve the free-vibration problem</a><a id="Solve-the-free-vibration-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-free-vibration-problem" title="Permalink"></a></h2><p>Find this many natural frequencies:</p><pre><code class="language-julia hljs">neigvs = 20</code></pre><p>Since the structure is free-floating, mass shifting must be employed to obtain the solution with the singular stiffness matrix. We are simply guessing a frequency between zero and the first fundamental frequency.</p><pre><code class="language-julia hljs">oshift = (2*pi*0.5)^2;</code></pre><p>The Arnoldi algorithm implemented in the well-known <code>Arpack</code> package is used to solve the generalized eigenvalue problem with the sparse matrices. As is common in structural dynamics, we request the smallest eigenvalues in absolute value (<code>:SM</code>).</p><pre><code class="language-julia hljs">using Arpack
evals, evecs, nconv = eigs(Kt + oshift * Mt, Mt; nev=neigvs, which=:SM, explicittransform = :none);</code></pre><p>First  we should check that the requested eigenvalues actually converged:</p><pre><code class="language-julia hljs">@show nconv == neigvs</code></pre><p>The eigenvalues (i. e. the squares of the angular frequencies) are returned in the vector <code>evals</code>. The mode shapes constitute the columns of the matrix <code>evecs</code>.</p><pre><code class="language-julia hljs">@show size(evecs)</code></pre><p>The natural frequencies are obtained from the squares of the angular frequencies. We note the use of <code>sqrt.</code> which broadcast the square root over the array <code>evals</code>.</p><pre><code class="language-julia hljs">fs = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);

#</code></pre><h2 id="Comparison-of-computed-and-analytical-results"><a class="docs-heading-anchor" href="#Comparison-of-computed-and-analytical-results">Comparison of computed and analytical results</a><a id="Comparison-of-computed-and-analytical-results-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-computed-and-analytical-results" title="Permalink"></a></h2><p>Set of modes measured by participant C.</p><table><tr><th style="text-align: right">Mode</th><th style="text-align: right">Description</th><th style="text-align: right">Frequency</th></tr><tr><td style="text-align: right">1.-6.</td><td style="text-align: right">&quot;Rigid body&quot; modes</td><td style="text-align: right">0</td></tr><tr><td style="text-align: right">7.</td><td style="text-align: right">Two node bending</td><td style="text-align: right">6.37 Hz</td></tr><tr><td style="text-align: right">8.</td><td style="text-align: right">Global fuselage rotation</td><td style="text-align: right">16.10 Hz</td></tr><tr><td style="text-align: right">9.</td><td style="text-align: right">First antisymmetric wing torsion</td><td style="text-align: right">33.13 Hz</td></tr><tr><td style="text-align: right">10.</td><td style="text-align: right">First symmetric wing torsion</td><td style="text-align: right">33.53 Hz</td></tr><tr><td style="text-align: right">11.</td><td style="text-align: right">Three node bending</td><td style="text-align: right">35.65 Hz</td></tr></table><p>The approximate and analytical frequencies are now reported.</p><pre><code class="language-julia hljs">sigdig(n) = round(n * 1000) / 1000

println(&quot;Frequencies 7 and higher&quot;)
println(&quot;Approximate: $(sigdig.(fs[7:end])) [Hz]&quot;)
println(&quot;Participant C experimental: $([6.37, 16.10, 33.13, 33.53, 35.65, 48.38, 49.43, 55.08]) [Hz]&quot;)

#</code></pre><h2 id="Visualize-vibration-modes"><a class="docs-heading-anchor" href="#Visualize-vibration-modes">Visualize vibration modes</a><a id="Visualize-vibration-modes-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-vibration-modes" title="Permalink"></a></h2><p>The animation will show one of the vibration modes overlaid on the undeformed geometry. The configuration during the animation needs to reflect rotations. The function <code>update_rotation_field!</code> will update the rotation field given a vibration mode.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.RotUtilModule: update_rotation_field!</code></pre><p>The visualization utilities take advantage of the PlotlyJS library.</p><pre><code class="language-julia hljs">using PlotlyJS
using VisualStructures: plot_space_box, plot_solid, render, react!, default_layout_3d, save_to_json</code></pre><p>The magnitude of the vibration modes (displacements  and rotations) will be amplified with this scale factor:</p><pre><code class="language-julia hljs">scale = 0.3</code></pre><p>The animation is encapsulated in a little function:</p><pre><code class="language-julia hljs">vis(mode) = begin
    tbox = plot_space_box(reshape(inflatebox!(boundingbox(fens.xyz), 4*L), 2, 3))
    tenv0 = tbox
    for fes in fesa
        t = plot_solid(fens, fes; x=geom0.values, u=0.0 .* dchi.values[:, 1:3], R=Rfield0.values, facecolor=&quot;rgb(125, 155, 125)&quot;, opacity=0.3);
        tenv0 = cat(tenv0, t; dims=1)
    end
    plots = tenv0
    layout = default_layout_3d(;title = &quot;Mode $(mode), $(sigdig.(fs[mode])) [Hz]&quot;)
    layout[:scene][:aspectmode] = &quot;data&quot;
    pl = render(plots; layout=layout)
    sleep(0.115)
    for xscale in scale .* sin.(collect(0:1:89) .* (2 * pi / 21))
        scattersysvec!(dchi, xscale .* evecs[:, mode])
        u1 = deepcopy(u0)
        u1.values .= dchi.values[:, 1:3]
        Rfield1 = deepcopy(Rfield0)
        update_rotation_field!(Rfield1, dchi)
        plots = tenv0
        for fes in fesa
            tenv1 = plot_solid(fens, fes; x=geom0.values, u=dchi.values[:, 1:3], R=Rfield1.values, facecolor=&quot;rgb(50, 55, 125)&quot;);
            plots = cat(plots, tenv1; dims=1)
        end
        react!(pl, plots, pl.plot.layout)
        sleep(0.08)
    end
end

#</code></pre><p>This is the mode that will be animated:</p><pre><code class="language-julia hljs">vis(7)

nothing</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 14 January 2022 01:13">Friday 14 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
