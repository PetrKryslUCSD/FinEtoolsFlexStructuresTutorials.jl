<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modal analysis of Argyris frame: effect of prestress · FinEtoolsFlexBeamsTutorials.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FinEtoolsFlexBeamsTutorials.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="argyris_frame_modal_tut.html">Modal analysis of Argyris frame: effect of prestress</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="argyris_frame_modal_tut.html">Modal analysis of Argyris frame: effect of prestress</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtoolsFlexBeamsTutorials.jl/blob/master/docs/src/tutorials/argyris_frame_modal_tut.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modal-analysis-of-Argyris-frame:-effect-of-prestress"><a class="docs-heading-anchor" href="#Modal-analysis-of-Argyris-frame:-effect-of-prestress">Modal analysis of Argyris frame: effect of prestress</a><a id="Modal-analysis-of-Argyris-frame:-effect-of-prestress-1"></a><a class="docs-heading-anchor-permalink" href="#Modal-analysis-of-Argyris-frame:-effect-of-prestress" title="Permalink"></a></h1><p>Source code: <a href="argyris_frame_modal_tut.jl"><code>argyris_frame_modal_tut.jl</code></a></p><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>Vibration analysis of a L-shaped frame under a loading. The fundamental vibration frequency depends on the prestress force.</p><h2 id="Goals"><a class="docs-heading-anchor" href="#Goals">Goals</a><a id="Goals-1"></a><a class="docs-heading-anchor-permalink" href="#Goals" title="Permalink"></a></h2><ul><li>Construct an L-shaped frame by merging individual members.</li><li>Compute the geometric stiffness.</li><li>Evaluate the effect of prestress on the fundamental frequency of vibration.</li></ul><p>The finite element code relies on the basic functionality implemented in this package.</p><pre><code class="language-julia">using FinEtools</code></pre><p>The linear deformation code will be needed to evaluate the loading.</p><pre><code class="language-julia">using FinEtoolsDeforLinear</code></pre><p>The functionality concerning beam models comes from these modules.</p><pre><code class="language-julia">using FinEtoolsFlexBeams.CrossSectionModule: CrossSectionRectangle
using FinEtoolsFlexBeams.RotUtilModule:  update_rotation_field!
using FinEtoolsFlexBeams.MeshFrameMemberModule: frame_member, merge_members
using FinEtoolsFlexBeams.RotUtilModule: initial_Rfield
using FinEtoolsFlexBeams.FEMMCorotBeamModule: FEMMCorotBeam
using FinEtoolsFlexBeams.FEMMCorotBeamModule
CB = FEMMCorotBeamModule</code></pre><p>Parameters:</p><pre><code class="language-julia">E = 71240.0 * phun(&quot;MPa&quot;)
nu = 0.31; # Poisson ratio
rho = 5000 * phun(&quot;kg/m^3&quot;);</code></pre><p>cross-sectional dimensions and length of each leg in millimeters</p><pre><code class="language-julia">b = 0.6 * phun(&quot;mm&quot;); h = 30.0 * phun(&quot;mm&quot;); L = 240.0 * phun(&quot;mm&quot;);</code></pre><p>Magnitude of the total applied force, Newton</p><pre><code class="language-julia">magn = 1e-5 * phun(&quot;N&quot;);</code></pre><p>Cross-sectional properties</p><pre><code class="language-julia">cs = CrossSectionRectangle(s -&gt; b, s -&gt; h, s -&gt; [0.0, 1.0, 0.0])

#</code></pre><h2 id="Generate-the-discrete-model"><a class="docs-heading-anchor" href="#Generate-the-discrete-model">Generate the discrete model</a><a id="Generate-the-discrete-model-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-the-discrete-model" title="Permalink"></a></h2><p>Select the number of elements per leg.</p><pre><code class="language-julia">n = 8;
members = Tuple{FENodeSet, AbstractFESet}[]
push!(members, frame_member([0 0 L; L 0 L], n, cs))
push!(members, frame_member([L 0 L; L 0 0], n, cs))
fens, fes = merge_members(members; tolerance = L / 10000)</code></pre><p>Construct the requisite fields, geometry and displacement Initialize configuration variables</p><pre><code class="language-julia">geom0 = NodalField(fens.xyz)
u0 = NodalField(zeros(size(fens.xyz,1), 3))
Rfield0 = initial_Rfield(fens)
dchi = NodalField(zeros(size(fens.xyz,1), 6))</code></pre><p>Apply EBC&#39;s</p><pre><code class="language-julia">l1 = selectnode(fens; box = [0 0 0 0 L L], tolerance = L / 10000)
for i in [1, 2, 3, 4, 5, 6]
    setebc!(dchi, l1, true, i)
end
applyebc!(dchi)
numberdofs!(dchi);</code></pre><p>Assemble the global discrete system</p><p>Material properties</p><pre><code class="language-julia">material = MatDeforElastIso(DeforModelRed3D, rho, E, nu, 0.0)

femm = FEMMCorotBeam(IntegDomain(fes, GaussRule(1, 2)), material)
K = CB.stiffness(femm, geom0, u0, Rfield0, dchi);
M = CB.mass(femm, geom0, u0, Rfield0, dchi);</code></pre><p>Construct force intensity,  loaded boundary, and assemble the load.</p><pre><code class="language-julia">tipn = selectnode(fens; box=[L L 0 0  0 0], tolerance=L/n/1000)[1]
loadbdry = FESetP1(reshape([tipn], 1, 1))
lfemm = FEMMBase(IntegDomain(loadbdry, PointRule()))
fi = ForceIntensity(FFlt[-magn, 0, 0, 0, 0, 0]);
F = CB.distribloads(lfemm, geom0, dchi, fi, 3);</code></pre><p>Solve for the displacement under the static load.</p><pre><code class="language-julia">scattersysvec!(dchi, K\F);</code></pre><p>Update deflections and rotations so that the initial stress can be computed. First the displacements:</p><pre><code class="language-julia">u1 = deepcopy(u0)
u1.values .= dchi.values[:, 1:3]</code></pre><p>Then the rotations:</p><pre><code class="language-julia">Rfield1 = deepcopy(Rfield0)
update_rotation_field!(Rfield1, dchi)</code></pre><p>The static deflection is now used to compute the internal forces which in turn lead to the geometric stiffness.</p><pre><code class="language-julia">Kg = CB.geostiffness(femm, geom0, u1, Rfield1, dchi);

#</code></pre><h2 id="Solution-of-the-eigenvalue-free-vibration-problem"><a class="docs-heading-anchor" href="#Solution-of-the-eigenvalue-free-vibration-problem">Solution of the eigenvalue free-vibration problem</a><a id="Solution-of-the-eigenvalue-free-vibration-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-of-the-eigenvalue-free-vibration-problem" title="Permalink"></a></h2><pre><code class="language-julia">using Arpack</code></pre><p>We will solve for this many natural frequencies. Then, since they are ordered by magnitude, we will pick the fundamental by taking the first from the list.</p><pre><code class="language-julia">neigvs = 4</code></pre><p>First we will  sweep through the loading factors that are positive, meaning the force points in the direction in which it was defined (towards the clamped end of the frame).</p><pre><code class="language-julia">lfp = linearspace(0.0, 68000.0, 400)
fsp = let
    fsp = Float64[]
    for load_factor in lfp
        evals, evecs, nconv = eigs(K + load_factor .* Kg, M; nev=neigvs, which=:SM);
        f = evals[1] &gt; 0 ? sqrt(evals[1]) / (2 * pi) : 0;
        push!(fsp, f)
    end
    fsp
end</code></pre><p>Next, we will sweep through arrange of negative load factors: this simply turns the force around so that it points away from the clamped end. This can also buckle the frame, but the magnitude is higher.</p><pre><code class="language-julia">lfm = linearspace(-109000.0, 0.0, 400)
fsm = let
    fsm = Float64[]
    for load_factor in lfm
        evals, evecs, nconv = eigs(K + load_factor .* Kg, M; nev=neigvs, which=:SM);
        f = evals[1] &gt; 0 ? sqrt(evals[1]) / (2 * pi) : 0;
        push!(fsm, f)
    end
    fsm
end

#</code></pre><h2 id="Plot-of-the-fundamental-frequency-is-it-depends-on-the-loading-factor"><a class="docs-heading-anchor" href="#Plot-of-the-fundamental-frequency-is-it-depends-on-the-loading-factor">Plot of the fundamental frequency is it depends on the loading factor</a><a id="Plot-of-the-fundamental-frequency-is-it-depends-on-the-loading-factor-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-of-the-fundamental-frequency-is-it-depends-on-the-loading-factor" title="Permalink"></a></h2><pre><code class="language-julia">using Gnuplot</code></pre><p>We concatenate the ranges for the load factors and the calculated fundamental frequencies and present them in a single plot.</p><pre><code class="language-julia">Gnuplot.gpexec(&quot;reset session&quot;)
@gp  &quot;set terminal windows 0 &quot;  :-

@gp  :- cat(collect(lfp), collect(lfm); dims=1) cat(fsp, fsm; dims=1) &quot; lw 2 lc rgb &#39;red&#39; with p title &#39;Fundamental frequency&#39; &quot;  :-

@gp  :- &quot;set xlabel &#39;Loading factor P&#39;&quot; :-
@gp  :- &quot;set ylabel &#39;Frequency(P) [Hz]&#39;&quot; :-
@gp  :- &quot;set title &#39;Frame fundamental frequency&#39;&quot;</code></pre><p>Clearly, the curve giving the dependence of the fundamental frequency on the loading factor consists of two branches. These two branches correspond to two different buckling modes: one for the positive orientation of the force and one for the negative orientation.</p><pre><code class="language-julia">#</code></pre><h2 id="Visualize-some-fundamental-mode-shapes"><a class="docs-heading-anchor" href="#Visualize-some-fundamental-mode-shapes">Visualize some fundamental mode shapes</a><a id="Visualize-some-fundamental-mode-shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-some-fundamental-mode-shapes" title="Permalink"></a></h2><p>Here we visualize the fundamental vibration modes for different values of the loading factor.</p><pre><code class="language-julia">using PlotlyJS
using FinEtoolsFlexBeams.VisUtilModule: plot_space_box, plot_solid, render, react!, default_layout_3d, save_to_json
scale = 0.005

vis(loading_factor, evec) = let
    tbox = plot_space_box(reshape(inflatebox!(boundingbox(fens.xyz), 0.3 * L), 2, 3))
    tenv0 = plot_solid(fens, fes; x=geom0.values, u=0.0 .* dchi.values[:, 1:3], R=Rfield0.values, facecolor=&quot;rgb(125, 155, 125)&quot;, opacity=0.3);
    plots = cat(tbox, tenv0; dims=1)
    layout = default_layout_3d(;width=600, height=600)
    layout[:scene][:aspectmode] = &quot;data&quot;
    pl = render(plots; layout=layout, title = &quot;Loading factor $(loading_factor)&quot;)
    for xscale in scale .* sin.(collect(0:1:89) .* (2 * pi / 21))
        scattersysvec!(dchi, xscale .* evec)
        u1 = deepcopy(u0)
        u1.values .= dchi.values[:, 1:3]
        Rfield1 = deepcopy(Rfield0)
        update_rotation_field!(Rfield1, dchi)
        tenv1 = plot_solid(fens, fes; x=geom0.values, u=dchi.values[:, 1:3], R=Rfield1.values, facecolor=&quot;rgb(50, 55, 125)&quot;);
        plots = cat(tbox, tenv0, tenv1; dims=1)
        react!(pl, plots, pl.plot.layout)
        sleep(0.115)
    end
end</code></pre><p>This is the vibration mode in the lead up to the buckling mode for the positive orientation of the force.</p><pre><code class="language-julia">loading_factor = 60000
evals, evecs, nconv = eigs(K + loading_factor .* Kg, M; nev=neigvs, which=:SM);
vis(loading_factor, evecs[:, 1])</code></pre><p>This is the same vibration mode for the negative orientation of the force, but note that the associated fundamental frequency increased due to the effect of the force upon the stiffening of the clamped leg of the frame that is now in tension, and therefore stiffer.</p><pre><code class="language-julia">loading_factor = -50000
evals, evecs, nconv = eigs(K + loading_factor .* Kg, M; nev=neigvs, which=:SM);
vis(loading_factor, evecs[:, 1])</code></pre><p>Increasing the load factor in the negative orientation further, the fundamental frequency will switch: it will be a different mode shape, the one that is close to the buckling mode shape for this orientation of the force.</p><pre><code class="language-julia">loading_factor = -100000
evals, evecs, nconv = eigs(K + loading_factor .* Kg, M; nev=neigvs, which=:SM);
vis(loading_factor, evecs[:, 1])

true</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 31 August 2020 17:38">Monday 31 August 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
