<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GARTEUR SM-AG19 Testbed: Harmonic Vibration Analysis · FinEtoolsFlexStructuresTutorials.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">FinEtoolsFlexStructuresTutorials.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="garteur_hva_tut.html">GARTEUR SM-AG19 Testbed: Harmonic Vibration Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="garteur_hva_tut.html">GARTEUR SM-AG19 Testbed: Harmonic Vibration Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtoolsFlexStructuresTutorials.jl/blob/master/docs/src/tutorials/garteur_hva_tut.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GARTEUR-SM-AG19-Testbed:-Harmonic-Vibration-Analysis"><a class="docs-heading-anchor" href="#GARTEUR-SM-AG19-Testbed:-Harmonic-Vibration-Analysis">GARTEUR SM-AG19 Testbed: Harmonic Vibration Analysis</a><a id="GARTEUR-SM-AG19-Testbed:-Harmonic-Vibration-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#GARTEUR-SM-AG19-Testbed:-Harmonic-Vibration-Analysis" title="Permalink"></a></h1><p>Source code: <a href="garteur_hva_tut.jl"><code>garteur_hva_tut.jl</code></a></p><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>This virtual test application is based on the test article used by the GARTEUR Structures &amp; Materials Action Group 19 which organized a Round Robin exercise where 12 European laboratories tested a single structure between 1995 and 1997. The benchmark structure was a laboratory structure built to simulate the dynamic behaviour of an aeroplane. The structure was initially built for a benchmark study on experimental modal analysis conducted by the Structures and Materials Action Group (SM-AG19) of the Group for Aeronautical Research and Technology in EURope (GARTEUR). The test-bed was designed and manufactured by ONERA, France.</p><p><img src="IMAC97photo.png" alt/></p><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><p>[1] Ground Vibration Test Techniques, compiled by A Gravelle, GARTEUR Structures &amp; Materials Action Group 19 Technical report TP-115, 1999. [2] Etienne Balmes, Jan R. Wright, GARTEUR GROUP ON GROUND VIBRATION TESTING | RESULTS FROM THE TEST OF A SINGLE STRUCTURE BY 12 LABORATORIES IN EUROPE, Proceedings of DETC&#39;97, 1997 ASME Design Engineering Technical Conferences, September 14-17, 1997, Sacramento, California. [3] 3M(TM) Viscoelastic Damping Polymer 112 Series,  Technical Data, May 2017.</p><h2 id="Goals"><a class="docs-heading-anchor" href="#Goals">Goals</a><a id="Goals-1"></a><a class="docs-heading-anchor-permalink" href="#Goals" title="Permalink"></a></h2><ul><li>Show how to construct model from multiple connected beams.</li><li>Demonstrate the use of massless connectors.</li><li>Demonstrate the use of point masses.</li><li>Demonstrate the use of grounded springs.</li><li>Illustrate verification of the solution of the free vibration problem.</li></ul><h2 id="Geometry-of-the-testbed-airplane."><a class="docs-heading-anchor" href="#Geometry-of-the-testbed-airplane.">Geometry of the testbed airplane.</a><a id="Geometry-of-the-testbed-airplane.-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-of-the-testbed-airplane." title="Permalink"></a></h2><p>It was a rather simple structure which was reasonably dynamically representative of a simple airplane structure. It was composed of several beams simulating a fuselage with wings and a tail. Wing tip drums allowed to adjust bending and torsion frequencies similarly to airplane ones, with some very close modal frequencies.</p><p><img src="garteur-geom.png" alt/></p><p>The script included below defines the geometry of the structure, the cross-sectional properties, the connectivity, and the location of the nodes.</p><pre><code class="language-julia hljs">include(&quot;garteur_geometry_tut.jl&quot;)</code></pre><p>The geometry is visualized in the tutorial <a href="garteur_geometry_vis_tut.jl">garteur<em>geometry</em>vis_tut</a>.</p><h2 id="Material"><a class="docs-heading-anchor" href="#Material">Material</a><a id="Material-1"></a><a class="docs-heading-anchor-permalink" href="#Material" title="Permalink"></a></h2><p>Material properties can be now used to create a material: isotropic elasticity model of the <code>FinEtoolsDeforLinear</code> package is instantiated.</p><pre><code class="language-julia hljs">using FinEtoolsDeforLinear</code></pre><p>The material of the structure is aluminum. The elastic modulus:</p><pre><code class="language-julia hljs">E = 70000.0 * phun(&quot;MPa&quot;)
nu = 0.31;</code></pre><p>The mass density:</p><pre><code class="language-julia hljs">rho = 2700 * phun(&quot;kg/m^3&quot;)
alu = MatDeforElastIso(DeforModelRed3D, rho, E, nu, 0.0)</code></pre><p>Material for the massless connectors has the mass density set to zero; otherwise it has the same properties as the aluminum material  of the structure.</p><pre><code class="language-julia hljs">massless = MatDeforElastIso(DeforModelRed3D, 0.0, alu.E, alu.nu, 0.0)</code></pre><p>This simple function returns material based on the label of the beam elements.</p><pre><code class="language-julia hljs">getmaterial(labl) = begin
    if labl &gt;= 7
        return massless
    end
    return alu
end</code></pre><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><p>Now we start constructing the discrete finite element model. We begin by constructing the requisite fields, geometry and displacement. These are the so-called &quot;configuration variables&quot;, all initialized to 0. This is that geometry field.</p><pre><code class="language-julia hljs">geom0 = NodalField(fens.xyz)</code></pre><p>This is the displacement field, three unknown displacements per node.</p><pre><code class="language-julia hljs">u0 = NodalField(zeros(size(fens.xyz, 1), 3))</code></pre><p>This is the rotation field, three unknown rotations per node are represented with a rotation matrix, in total nine numbers. The utility function <code>initial_Rfield</code></p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.RotUtilModule: initial_Rfield
Rfield0 = initial_Rfield(fens)</code></pre><p>Finally, this is the displacement and rotation field for incremental changes, incremental displacements and incremental rotations. In total, 6 unknowns per node. Note that the the incremental displacements are in general complex.</p><pre><code class="language-julia hljs">dchi = NodalField(0.0im .* zeros(size(fens.xyz, 1), 6))</code></pre><p>There are no support conditions.</p><pre><code class="language-julia hljs">applyebc!(dchi)</code></pre><p>The  the number of free(unknown) degrees of freedom is equal to the total number of degrees of freedom in the system.</p><pre><code class="language-julia hljs">numberdofs!(dchi);</code></pre><h2 id="Identify-support-points-and-locations-of-sensors"><a class="docs-heading-anchor" href="#Identify-support-points-and-locations-of-sensors">Identify support points and locations of sensors</a><a id="Identify-support-points-and-locations-of-sensors-1"></a><a class="docs-heading-anchor-permalink" href="#Identify-support-points-and-locations-of-sensors" title="Permalink"></a></h2><p>Suspension points are at these nodes:</p><pre><code class="language-julia hljs">suspln = selectnode(fens; box = initbox!(Float64[], vec([0.0*L 0.0*L 0.805*L])), inflate = tolerance)
susprn = selectnode(fens; box = initbox!(Float64[], vec([0.0*L -0.0*L 0.805*L])), inflate = tolerance)
suspbn = selectnode(fens; box = initbox!(Float64[], vec([-2.0*L 0.0*L 0.0*L])), inflate = tolerance)</code></pre><p>Find out at which nodes the sensors are:</p><pre><code class="language-julia hljs">sensors = Dict()
sensors = let</code></pre><p>The sensors at the tip of the left and right wing drum</p><pre><code class="language-julia hljs">    sensor112n = selectnode(fens; box = initbox!(Float64[], vec([+1.8*L 9.8*L 0.96*L])), inflate = tolerance)
    sensors[112] = sensor112n
    sensor12n = selectnode(fens; box = initbox!(Float64[], vec([+1.8*L -9.8*L .96*L])), inflate = tolerance)
    sensors[12] = sensor12n
    sensor111n = selectnode(fens; box = initbox!(Float64[], vec([-1.8*L 9.8*L 0.96*L])), inflate = tolerance)
    sensors[111] = sensor111n
    sensor11n = selectnode(fens; box = initbox!(Float64[], vec([-1.8*L -9.8*L .96*L])), inflate = tolerance)
    sensors[11] = sensor11n</code></pre><p>The joint between the horizontal and vertical tail parts</p><pre><code class="language-julia hljs">    sensor202n = selectnode(fens; box = initbox!(Float64[], vec([-8*L 0 3.8*L])), inflate = tolerance)
    sensors[202] = sensor202n
    sensors
end</code></pre><h2 id="Assemble-the-global-discrete-system"><a class="docs-heading-anchor" href="#Assemble-the-global-discrete-system">Assemble the global discrete system</a><a id="Assemble-the-global-discrete-system-1"></a><a class="docs-heading-anchor-permalink" href="#Assemble-the-global-discrete-system" title="Permalink"></a></h2><p>For disambiguation we will refer to the stiffness and mass functions by qualifying them with the corotational-beam module, <code>FEMMCorotBeamModule</code>.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.FEMMCorotBeamModule
CB = FEMMCorotBeamModule</code></pre><p>Note that we have an array of finite element sets. We compute the matrices for each set separately and accumulate them into the final overall matrix. Thus we can construct the stiffness and mass matrix as follows.</p><pre><code class="language-julia hljs">using  SparseArrays</code></pre><p>Loop over all the finite element sets and add up their contributions, the stiffness in the mass matrix for each.</p><pre><code class="language-julia hljs">Kf, Kd, M = let
    Kf = spzeros(dchi.nfreedofs, dchi.nfreedofs)
    Kd = spzeros(dchi.nfreedofs, dchi.nfreedofs)
    M = spzeros(dchi.nfreedofs, dchi.nfreedofs)
    for fes in fesa
        labl  = fes.label[1]
        femm = CB.FEMMCorotBeam(IntegDomain(fes, GaussRule(1, 2)), getmaterial(labl));
        if labl == 7 # connectors representing the damping layer
            Kd += CB.stiffness(femm, geom0, u0, Rfield0, dchi);
        else
            Kf += CB.stiffness(femm, geom0, u0, Rfield0, dchi);
        end
        M += CB.mass(femm, geom0, u0, Rfield0, dchi);
    end
    Kf, Kd, M
end</code></pre><h2 id="Additional-concentrated-masses."><a class="docs-heading-anchor" href="#Additional-concentrated-masses.">Additional concentrated masses.</a><a id="Additional-concentrated-masses.-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-concentrated-masses." title="Permalink"></a></h2><pre><code class="language-julia hljs">using LinearAlgebra

using FinEtoolsFlexStructures.FEMMPointMassModule
PM = FEMMPointMassModule</code></pre><p>There is a sensor on the tail.</p><pre><code class="language-julia hljs">femmcm1 =  PM.FEMMPointMass(IntegDomain(FESetP1(reshape(sensors[202], 1, 1)), PointRule()), FFltMat(2*L*L/5*L/5*2*rho*LinearAlgebra.I(3)));</code></pre><p>These are the forward/interior locations on the wing drums where the compensation masses are attached.</p><pre><code class="language-julia hljs">mass1n = selectnode(fens; box = initbox!(Float64[], vec([1.8*L 9.2*L .96*L])), inflate = tolerance)
mass2n = selectnode(fens; box = initbox!(Float64[], vec([1.8*L -9.2*L .96*L])), inflate = tolerance)
femmcm2 =  PM.FEMMPointMass(IntegDomain(FESetP1(reshape([mass1n; mass2n;], 2, 1)), PointRule()), FFltMat(0.2*phun(&quot;kg&quot;)*LinearAlgebra.I(3)));

Mp = PM.mass(femmcm1, geom0, u0, Rfield0, dchi) + PM.mass(femmcm2, geom0, u0, Rfield0, dchi);</code></pre><h2 id="Bungee-supports"><a class="docs-heading-anchor" href="#Bungee-supports">Bungee supports</a><a id="Bungee-supports-1"></a><a class="docs-heading-anchor-permalink" href="#Bungee-supports" title="Permalink"></a></h2><p>This is the assumed stifffness of the bungee cords (each one separately).</p><pre><code class="language-julia hljs">bungeecoefficient = 4000*phun(&quot;N/m&quot;);

using LinearAlgebra

using FinEtoolsFlexStructures.FEMMPointGroundedSpringModule
BS = FEMMPointGroundedSpringModule</code></pre><p>There are three suspension points at the top of the fuselage. We assume that these bungee supports exert only reaction in the vertical direction.</p><pre><code class="language-julia hljs">femmbs =  BS.FEMMPointGroundedSpring(IntegDomain(FESetP1(reshape([suspln; susprn; suspbn;], 3, 1)), PointRule()),
FFltMat([bungeecoefficient*[0;0;1]*[0;0;1]&#39; 0*LinearAlgebra.I(3); 0*LinearAlgebra.I(3) 0*LinearAlgebra.I(3)]));

Kb = BS.stiffness(femmbs, geom0, u0, Rfield0, dchi)</code></pre><h2 id="Damping"><a class="docs-heading-anchor" href="#Damping">Damping</a><a id="Damping-1"></a><a class="docs-heading-anchor-permalink" href="#Damping" title="Permalink"></a></h2><p>The overall damping ratios measured in the physical experiments were approximately 1%. Damping levels thought appropriate for obtaining realistic damping were obtained through the use of a viscoelastic layer glued to the wing beam with an aluminum constraining plate on top.</p><h3 id="Viscoelastic-damping-layer"><a class="docs-heading-anchor" href="#Viscoelastic-damping-layer">Viscoelastic damping layer</a><a id="Viscoelastic-damping-layer-1"></a><a class="docs-heading-anchor-permalink" href="#Viscoelastic-damping-layer" title="Permalink"></a></h3><p>The properties of the material of the viscoelastic layer were described in the technical specification [3]. Since the properties are frequency dependent, we take as a representative value the numbers obtained for 20 Hz.</p><p>The viscoelastic used was the 3M acrylic viscoelastic polymer ISD 112 in the form of a tape of 76 mm width with thickness of 50 microm.  This material is particularly well suited for the testbed operating range of 5-50 Hz and at 20 degrees C where the loss factor is near its peak of 0.4 [3]. These are representative quantities taken at 20 Hz.</p><pre><code class="language-julia hljs">eta = 0.5
omega_5_50 = 2*pi*20</code></pre><p>The connectors between the wing beam and the constraining plate are taken as representative of the stiffness of the constraining layer. The viscoelastic damping is then taken as proportional to this stiffness.</p><pre><code class="language-julia hljs">Cd = (eta / omega_5_50) .* Kd</code></pre><h3 id="Aluminum-structure"><a class="docs-heading-anchor" href="#Aluminum-structure">Aluminum structure</a><a id="Aluminum-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Aluminum-structure" title="Permalink"></a></h3><p>We assume the loss factor of the fuselage, wing, and tail to be 0.01. This can be used to derive the damping model for these parts of the aircraft structure in the form of Rayleigh damping.</p><pre><code class="language-julia hljs">zeta= 0.01/2; # damping ratio
zeta_1= zeta; # damping ratio for mode 1
zeta_2= zeta; # damping ratio for mode 2</code></pre><p>Stiffness and mass proportional damping parameters.</p><pre><code class="language-julia hljs">omega_1=2*pi*6; # Guess
omega_2=2*pi*30; # Guess
rdmass = (2*1.0/(omega_2^2-omega_1^2)).*[omega_2^2 -omega_1^2]*[zeta_1*omega_1; zeta_2*omega_2];
rdstiffness = (2*1.0/(omega_2^2-omega_1^2)).*[-1 1]*[zeta_1*omega_1; zeta_2*omega_2];</code></pre><p>The airframe damping matrix is a mixture of the mass matrix and the stiffness matrix.</p><pre><code class="language-julia hljs">Cf = rdmass .* M + rdstiffness .* Kf;</code></pre><p>These are the system matrices. The stiffness consists of the contribution of the airframe, the connectors between the wing components, and the bungees of the suspension.</p><pre><code class="language-julia hljs">Kt = Kf + Kd + Kb</code></pre><p>The mass matrix is the contribution of the structure and the attached point masses (compensation masses).</p><pre><code class="language-julia hljs">Mt = M + Mp</code></pre><p>The damping matrix is composed of the damping of the overall structure, and of the damping layer (the connectors between the wing components).</p><pre><code class="language-julia hljs">Ct = Cf + Cd</code></pre><h2 id="Loading"><a class="docs-heading-anchor" href="#Loading">Loading</a><a id="Loading-1"></a><a class="docs-heading-anchor-permalink" href="#Loading" title="Permalink"></a></h2><p>Here we assume that the stinger  was attached at the location of the sensor</p><ol><li>The force is vertical (in the Z direction) and the magnitude of the force</li></ol><p>is arbitrary.</p><pre><code class="language-julia hljs">forceat = 12
fmagn= 1.0;
loadbdry = FESetP1(reshape(sensors[forceat], 1, 1))
lfemm = FEMMBase(IntegDomain(loadbdry, PointRule()))</code></pre><p>The force is applied in the vertical direction, and we assume it is positive upwards.</p><pre><code class="language-julia hljs">fi = ForceIntensity(FFlt[0, 0.0, -fmagn, 0, 0, 0]);</code></pre><p>The force loading is now integrated over the &quot;volume&quot; of the integration domain.</p><pre><code class="language-julia hljs">F = CB.distribloads(lfemm, geom0, dchi, fi, 3);</code></pre><h2 id="Solve-the-Harmonic-vibration-problem"><a class="docs-heading-anchor" href="#Solve-the-Harmonic-vibration-problem">Solve the Harmonic vibration problem</a><a id="Solve-the-Harmonic-vibration-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-Harmonic-vibration-problem" title="Permalink"></a></h2><p>The frequency sweep will start at <code>fromf</code> and continue through the frequency <code>tof</code>.  The frequencies will be logarithmically distributed throughout this range.</p><pre><code class="language-julia hljs">fromf = 3.0
tof = 70.0
nf = 150
frequencies = logspace(log10(fromf), log10(tof), nf);</code></pre><p>Only a single number per sensor will be collected, the Z direction displacement.</p><pre><code class="language-julia hljs">receptance12 = fill(0.0im, nf)
receptance112 = fill(0.0im, nf)</code></pre><p>Now Loop over</p><pre><code class="language-julia hljs">for   fi in 1:length(frequencies)
    f =  frequencies[fi];
    om = 2*pi*f;</code></pre><p>Solve the system of complex  equations of balance:</p><pre><code class="language-julia hljs">    U = (-om^2*Mt + 1im*om*Ct + Kt) \ F</code></pre><p>Distribute the vector of the solution:</p><pre><code class="language-julia hljs">    scattersysvec!(dchi, U)</code></pre><p>Now sample the solution at the locations of the two sensors, 12 and 112:</p><pre><code class="language-julia hljs">    v = fill(0.0im, 6)
    gathervalues_asvec!(dchi, v, sensors[12])
    p_d = v[1:3];
    receptance12[fi] = p_d[3]/fmagn;
    gathervalues_asvec!(dchi, v, sensors[112])
    p_d = v[1:3];
    receptance112[fi] = p_d[3]/fmagn;
end</code></pre><p>The receptances were calculated above. The mobility and accelerance may be obtained in a postprocessing step.</p><pre><code class="language-julia hljs">oms = (2*pi) .* frequencies;
mobility12 = receptance12 .* (-1im*oms);
mobility112 = receptance112 .* (-1im*oms);
accelerance12 = receptance12 .* (-oms.^2);
accelerance112 = receptance112 .* (-oms.^2);

results = Dict()
results[12] = Dict(&quot;receptance&quot;=&gt;receptance12, &quot;mobility&quot;=&gt;mobility12, &quot;accelerance&quot;=&gt;accelerance12)
results[112] = Dict(&quot;receptance&quot;=&gt;receptance112, &quot;mobility&quot;=&gt;mobility112, &quot;accelerance&quot;=&gt;accelerance112)</code></pre><h2 id="Present-the-results-graphically"><a class="docs-heading-anchor" href="#Present-the-results-graphically">Present the results graphically</a><a id="Present-the-results-graphically-1"></a><a class="docs-heading-anchor-permalink" href="#Present-the-results-graphically" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Gnuplot</code></pre><p>Plot the amplitude of the response curves. We output two curves. The first for the driving-point FRF:</p><pre><code class="language-julia hljs">quantity = &quot;accelerance&quot;; units = &quot;m/s^2/N&quot;
outputat = 12
y = abs.(results[outputat][quantity]) / phun(units)
@gp  &quot;set terminal windows 0 &quot;  :-
@gp  :- frequencies y &quot; lw 2 lc rgb &#39;blue&#39; with lines title &#39;output at $(outputat)&#39; &quot;  :-</code></pre><p>The second for the cross transfer:</p><pre><code class="language-julia hljs">outputat = 112
y = abs.(results[outputat][quantity]) / phun(units)
@gp  :- frequencies y &quot; lw 2 lc rgb &#39;red&#39; with lines title &#39;output at $(outputat)&#39; &quot;  :-
@gp  :- &quot;set logscale y&quot; :-
@gp  :- &quot;set xlabel &#39;Frequency [Hz]&#39;&quot; :-
@gp  :- &quot;set ylabel &#39;abs(H) [$(units)]&#39;&quot; :-
@gp  :- &quot;set title &#39;Force at $(forceat), $(quantity)&#39;&quot;</code></pre><p>Plot the phase shift of the response curves. Again we output two curves, the first for the driving-point FRF:</p><pre><code class="language-julia hljs">outputat = 12
y = atan.(imag(results[outputat][quantity]), real(results[outputat][quantity]))/pi*180
@gp  &quot;set terminal windows 1 &quot;  :-
@gp  :- frequencies y &quot; lw 2 lc rgb &#39;blue&#39; with lines title &#39;output at $(outputat)&#39; &quot;  :-</code></pre><p>The second for the cross transfer:</p><pre><code class="language-julia hljs">outputat = 112
y = atan.(imag(results[outputat][quantity]), real(results[outputat][quantity]))/pi*180
@gp  :- frequencies y &quot; lw 2 lc rgb &#39;red&#39; with lines title &#39;output at $(outputat)&#39; &quot;  :-
@gp  :- &quot;set xlabel &#39;Frequency [Hz]&#39;&quot; :-
@gp  :- &quot;set ylabel &#39;Phase shift [deg]&#39;&quot; :-
@gp  :- &quot;set title &#39;Force at $(forceat), $(quantity)&#39;&quot;


nothing</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 14 January 2022 04:12">Friday 14 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
