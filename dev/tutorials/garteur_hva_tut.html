<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GARTEUR SM-AG19 Testbed: Harmonic Vibration Analysis · FinEtoolsFlexBeamsTutorials.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FinEtoolsFlexBeamsTutorials.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="garteur_hva_tut.html">GARTEUR SM-AG19 Testbed: Harmonic Vibration Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="garteur_hva_tut.html">GARTEUR SM-AG19 Testbed: Harmonic Vibration Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtoolsFlexBeamsTutorials.jl/blob/master/docs/src/tutorials/garteur_hva_tut.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GARTEUR-SM-AG19-Testbed:-Harmonic-Vibration-Analysis"><a class="docs-heading-anchor" href="#GARTEUR-SM-AG19-Testbed:-Harmonic-Vibration-Analysis">GARTEUR SM-AG19 Testbed: Harmonic Vibration Analysis</a><a id="GARTEUR-SM-AG19-Testbed:-Harmonic-Vibration-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#GARTEUR-SM-AG19-Testbed:-Harmonic-Vibration-Analysis" title="Permalink"></a></h1><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>This virtual test application is based on the test article used by the GARTEUR Structures &amp; Materials Action Group 19 which organized a Round Robin exercise where 12 European laboratories tested a single structure between 1995 and 1997. The benchmark structure was a laboratory structure built to simulate the dynamic behaviour of an aeroplane. The structure was initially built for a benchmark study on experimental modal analysis conducted by the Structures and Materials Action Group (SM-AG19) of the Group for Aeronautical Research and Technology in EURope (GARTEUR). The test-bed was designed and manufactured by ONERA, France.</p><p><img src="IMAC97photo.jpg" alt/></p><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><p>[1] Ground Vibration Test Techniques, compiled by A Gravelle, GARTEUR Structures &amp; Materials Action Group 19 Technical report TP-115, 1999. [2] Etienne Balmes, Jan R. Wright, GARTEUR GROUP ON GROUND VIBRATION TESTING | RESULTS FROM THE TEST OF A SINGLE STRUCTURE BY 12 LABORATORIES IN EUROPE, Proceedings of DETC&#39;97, 1997 ASME Design Engineering Technical Conferences, September 14-17, 1997, Sacramento, California. [3] 3M(TM) Viscoelastic Damping Polymer 112 Series,  Technical Data, May 2017.</p><h2 id="Goals"><a class="docs-heading-anchor" href="#Goals">Goals</a><a id="Goals-1"></a><a class="docs-heading-anchor-permalink" href="#Goals" title="Permalink"></a></h2><ul><li>Show how to construct model from multiple connected beams.</li><li>Demonstrate the use of massless connectors.</li><li>Demonstrate the use of point masses.</li><li>Demonstrate the use of grounded springs.</li><li>Illustrate verification of the solution of the free vibration problem.</li></ul><pre><code class="language-julia">#</code></pre><h2 id="Geometry-of-the-testbed-airplane."><a class="docs-heading-anchor" href="#Geometry-of-the-testbed-airplane.">Geometry of the testbed airplane.</a><a id="Geometry-of-the-testbed-airplane.-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-of-the-testbed-airplane." title="Permalink"></a></h2><p>It was a rather simple structure which was reasonably dynamically representative of a simple airplane structure. It was composed of several beams simulating a fuselage with wings and a tail. Wing tip drums allowed to adjust bending and torsion frequencies similarly to airplane ones, with some very close modal frequencies.</p><p><img src="garteur-geom.png" alt/></p><p>The script included below defines the geometry of the structure, the cross-sectional properties, the connectivity, and the location of the nodes.</p><pre><code class="language-julia">include(&quot;garteur_geometry_tut.jl&quot;)</code></pre><p>The geometry is visualized in the tutorial <a href="garteur_geometry_vis_tut.jl">garteur<em>geometry</em>vis_tut</a>.</p><pre><code class="language-julia">#</code></pre><h2 id="Material"><a class="docs-heading-anchor" href="#Material">Material</a><a id="Material-1"></a><a class="docs-heading-anchor-permalink" href="#Material" title="Permalink"></a></h2><p>Material properties can be now used to create a material: isotropic elasticity model of the <code>FinEtoolsDeforLinear</code> package is instantiated.</p><pre><code class="language-julia">using FinEtoolsDeforLinear</code></pre><p>The material of the structure is aluminum. The elastic modulus:</p><pre><code class="language-julia">E = 70000.0 * phun(&quot;MPa&quot;)
nu = 0.31;</code></pre><p>The mass density:</p><pre><code class="language-julia">rho = 2700 * phun(&quot;kg/m^3&quot;)
alu = MatDeforElastIso(DeforModelRed3D, rho, E, nu, 0.0)</code></pre><p>Material for the massless connectors has the mass density set to zero; otherwise it has the same properties as the aluminum material  of the structure.</p><pre><code class="language-julia">massless = MatDeforElastIso(DeforModelRed3D, 0.0, alu.E, alu.nu, 0.0)</code></pre><p>This simple function returns material based on the label of the beam elements.</p><pre><code class="language-julia">material(labl) = begin
    if labl &gt;= 7
        return massless
    end
    return alu
end



#</code></pre><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><p>Now we start constructing the discrete finite element model. We begin by constructing the requisite fields, geometry and displacement. These are the so-called &quot;configuration variables&quot;, all initialized to 0. This is that geometry field.</p><pre><code class="language-julia">geom0 = NodalField(fens.xyz)</code></pre><p>This is the displacement field, three unknown displacements per node.</p><pre><code class="language-julia">u0 = NodalField(zeros(size(fens.xyz, 1), 3))</code></pre><p>This is the rotation field, three unknown rotations per node are represented with a rotation matrix, in total nine numbers. The utility function <code>initial_Rfield</code></p><pre><code class="language-julia">using FinEtoolsFlexBeams.RotUtilModule: initial_Rfield
Rfield0 = initial_Rfield(fens)</code></pre><p>Here we verify the number of nodes and the number of degrees of freedom in the rotation field per node.</p><pre><code class="language-julia">@show nents(Rfield0)
@show ndofs(Rfield0)</code></pre><p>Finally, this is the displacement and rotation field for incremental changes, incremental displacements and incremental rotations. In total, 6 unknowns per node. Note that the the incremental displacements are in general complex.</p><pre><code class="language-julia">dchi = NodalField(0.0im .* zeros(size(fens.xyz, 1), 6))</code></pre><p>There are no support conditions.</p><pre><code class="language-julia">applyebc!(dchi)</code></pre><p>The  the number of free(unknown) degrees of freedom is equal to the total number of degrees of freedom in the system.</p><pre><code class="language-julia">numberdofs!(dchi);

#</code></pre><h2 id="Identify-support-points-and-locations-of-sensors"><a class="docs-heading-anchor" href="#Identify-support-points-and-locations-of-sensors">Identify support points and locations of sensors</a><a id="Identify-support-points-and-locations-of-sensors-1"></a><a class="docs-heading-anchor-permalink" href="#Identify-support-points-and-locations-of-sensors" title="Permalink"></a></h2><p>Suspension points are at these nodes:</p><pre><code class="language-julia">suspln = selectnode(fens; box = initbox!(Float64[], vec([0.0*L 0.0*L 0.805*L])), inflate = tolerance)
susprn = selectnode(fens; box = initbox!(Float64[], vec([0.0*L -0.0*L 0.805*L])), inflate = tolerance)
suspbn = selectnode(fens; box = initbox!(Float64[], vec([-2.0*L 0.0*L 0.0*L])), inflate = tolerance)</code></pre><p>Find out at which nodes the sensors are:</p><pre><code class="language-julia">sensors = Dict()
sensors = let</code></pre><p>The sensors at the tip of the left and right wing drum</p><pre><code class="language-julia">    sensor112n = selectnode(fens; box = initbox!(Float64[], vec([+1.8*L 9.8*L 0.96*L])), inflate = tolerance)
    sensors[112] = sensor112n
    sensor12n = selectnode(fens; box = initbox!(Float64[], vec([+1.8*L -9.8*L .96*L])), inflate = tolerance)
    sensors[12] = sensor12n
    sensor111n = selectnode(fens; box = initbox!(Float64[], vec([-1.8*L 9.8*L 0.96*L])), inflate = tolerance)
    sensors[111] = sensor111n
    sensor11n = selectnode(fens; box = initbox!(Float64[], vec([-1.8*L -9.8*L .96*L])), inflate = tolerance)
    sensors[11] = sensor11n</code></pre><p>The joint between the horizontal and vertical tail parts</p><pre><code class="language-julia">    sensor202n = selectnode(fens; box = initbox!(Float64[], vec([-8*L 0 3.8*L])), inflate = tolerance)
    sensors[202] = sensor202n
    sensors
end

#</code></pre><h2 id="Assemble-the-global-discrete-system"><a class="docs-heading-anchor" href="#Assemble-the-global-discrete-system">Assemble the global discrete system</a><a id="Assemble-the-global-discrete-system-1"></a><a class="docs-heading-anchor-permalink" href="#Assemble-the-global-discrete-system" title="Permalink"></a></h2><p>For disambiguation we will refer to the stiffness and mass functions by qualifying them with the corotational-beam module, <code>FEMMCorotBeamModule</code>.</p><pre><code class="language-julia">using FinEtoolsFlexBeams.FEMMCorotBeamModule
CB = FEMMCorotBeamModule</code></pre><p>Note that we have an array of finite element sets. We compute the matrices for each set separately and accumulate them into the final overall matrix. Thus we can construct the stiffness and mass matrix as follows.</p><pre><code class="language-julia">using  SparseArrays</code></pre><p>Loop over all the finite element sets and add up their contributions, the stiffness in the mass matrix for each.</p><pre><code class="language-julia">Kf, Kd, M = let
    Kf = spzeros(dchi.nfreedofs, dchi.nfreedofs)
    Kd = spzeros(dchi.nfreedofs, dchi.nfreedofs)
    M = spzeros(dchi.nfreedofs, dchi.nfreedofs)
    for fes in fesa
        labl  = fes.label[1]
        femm = CB.FEMMCorotBeam(IntegDomain(fes, GaussRule(1, 2)), material(labl));
        if labl == 7 # connectors representing the damping layer
            Kd += CB.stiffness(femm, geom0, u0, Rfield0, dchi);
        else
            Kf += CB.stiffness(femm, geom0, u0, Rfield0, dchi);
        end
        M += CB.mass(femm, geom0, u0, Rfield0, dchi);
    end
    Kf, Kd, M
end

#</code></pre><h2 id="Additional-concentrated-masses."><a class="docs-heading-anchor" href="#Additional-concentrated-masses.">Additional concentrated masses.</a><a id="Additional-concentrated-masses.-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-concentrated-masses." title="Permalink"></a></h2><pre><code class="language-julia">using LinearAlgebra

using FinEtoolsFlexBeams.FEMMPointMassModule
PM = FEMMPointMassModule</code></pre><p>There is a sensor on the tail.</p><pre><code class="language-julia">femmcm1 =  PM.FEMMPointMass(IntegDomain(FESetP1(reshape([sensors[202];], 1, 1)), PointRule()), FFltMat(2*L*L/5*L/5*2*rho*I(3)));</code></pre><p>These are the forward/interior locations on the wing drums where the compensation masses are attached.</p><pre><code class="language-julia">mass1n = selectnode(fens; box = initbox!(Float64[], vec([1.8*L 9.2*L .96*L])), inflate = tolerance)
mass2n = selectnode(fens; box = initbox!(Float64[], vec([1.8*L -9.2*L .96*L])), inflate = tolerance)
femmcm2 =  PM.FEMMPointMass(IntegDomain(FESetP1(reshape([mass1n; mass2n;], 2, 1)), PointRule()), FFltMat(0.2*phun(&quot;kg&quot;)*I(3)));

Mp = PM.mass(femmcm1, geom0, u0, Rfield0, dchi) + PM.mass(femmcm2, geom0, u0, Rfield0, dchi);

#</code></pre><h2 id="Bungee-supports"><a class="docs-heading-anchor" href="#Bungee-supports">Bungee supports</a><a id="Bungee-supports-1"></a><a class="docs-heading-anchor-permalink" href="#Bungee-supports" title="Permalink"></a></h2><p>This is the assumed stifffness of the bungee cords (each one separately).</p><pre><code class="language-julia">bungeecoefficient = 4000*phun(&quot;N/m&quot;);

using LinearAlgebra

using FinEtoolsFlexBeams.FEMMPointGroundedSpringModule
BS = FEMMPointGroundedSpringModule</code></pre><p>There are three suspension points at the top of the fuselage. We assume that these bungee supports exert only reaction in the vertical direction.</p><pre><code class="language-julia">femmbs =  BS.FEMMPointGroundedSpring(IntegDomain(FESetP1(reshape([suspln; susprn; suspbn;], 3, 1)), PointRule()),
FFltMat([bungeecoefficient*[0;0;1]*[0;0;1]&#39; 0*I(3); 0*I(3) 0*I(3)]));

Kb = BS.stiffness(femmbs, geom0, u0, Rfield0, dchi)



#</code></pre><h2 id="Damping"><a class="docs-heading-anchor" href="#Damping">Damping</a><a id="Damping-1"></a><a class="docs-heading-anchor-permalink" href="#Damping" title="Permalink"></a></h2><p>The overall damping ratios measured in the physical experiments were approximately 1%. Damping levels thought appropriate for obtaining realistic damping were obtained through the use of a viscoelastic layer glued to the wing beam with an aluminum constraining plate on top.</p><h3 id="Viscoelastic-damping-layer"><a class="docs-heading-anchor" href="#Viscoelastic-damping-layer">Viscoelastic damping layer</a><a id="Viscoelastic-damping-layer-1"></a><a class="docs-heading-anchor-permalink" href="#Viscoelastic-damping-layer" title="Permalink"></a></h3><p>The properties of the material of the viscoelastic layer were described in the technical specification [3]. Since the properties are frequency dependent, we take as a representative value the numbers obtained for 20 Hz.</p><p>The viscoelastic used was the 3M acrylic viscoelastic polymer ISD 112 in the form of a tape of 76 mm width with thickness of 50 microm.  This material is particularly well suited for the testbed operating range of 5-50 Hz and at 20 degrees C where the loss factor is near its peak of 0.4 [3]. These are representative quantities taken at 20 Hz.</p><pre><code class="language-julia">eta = 0.5
omega_5_50 = 2*pi*20</code></pre><p>The connectors between the wing beam and the constraining plate are taken as representative of the stiffness of the constraining layer. The viscoelastic damping is then taken as proportional to this stiffness.</p><pre><code class="language-julia">Cd = (eta / omega_5_50) .* Kd</code></pre><h3 id="Aluminum-structure"><a class="docs-heading-anchor" href="#Aluminum-structure">Aluminum structure</a><a id="Aluminum-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Aluminum-structure" title="Permalink"></a></h3><p>We assume the loss factor of the fuselage, wing, and tail to be 0.01. This can be used to derive the damping model for these parts of the aircraft structure in the form of Rayleigh damping.</p><pre><code class="language-julia">zeta= 0.01/2; # damping ratio
zeta_1= zeta; # damping ratio for mode 1
zeta_2= zeta; # damping ratio for mode 2</code></pre><p>Stiffness and mass proportional damping parameters.</p><pre><code class="language-julia">omega_1=2*pi*6; # Guess
omega_2=2*pi*30; # Guess
rdmass = (2*1.0/(omega_2^2-omega_1^2)).*[omega_2^2 -omega_1^2]*[zeta_1*omega_1; zeta_2*omega_2];
rdstiffness = (2*1.0/(omega_2^2-omega_1^2)).*[-1 1]*[zeta_1*omega_1; zeta_2*omega_2];</code></pre><p>The airframe damping matrix is a mixture of the mass matrix and the stiffness matrix.</p><pre><code class="language-julia">Cf = rdmass .* M + rdstiffness .* Kf;</code></pre><p>These are the system matrices. The stiffness consists of the contribution of the airframe, the connectors between the wing components, and the bungees of the suspension.</p><pre><code class="language-julia">Kt = Kf + Kd + Kb</code></pre><p>The mass matrix is the contribution of the structure and the attached point masses (compensation masses).</p><pre><code class="language-julia">Mt = M + Mp</code></pre><p>The damping matrix is composed of the damping of the overall structure, and of the damping layer (the connectors between the wing components).</p><pre><code class="language-julia">Ct = Cf + Cd

#</code></pre><h2 id="Loading"><a class="docs-heading-anchor" href="#Loading">Loading</a><a id="Loading-1"></a><a class="docs-heading-anchor-permalink" href="#Loading" title="Permalink"></a></h2><p>Here we assume that the stinger  was attached at the location of the sensor</p><ol><li>The force is vertical (in the Z direction) and the magnitude of the force</li></ol><p>is arbitrary.</p><pre><code class="language-julia">forceat = 12
fmagn= 1.0;
loadbdry = FESetP1(reshape(sensors[forceat], 1, 1))
lfemm = FEMMBase(IntegDomain(loadbdry, PointRule()))</code></pre><p>The force is applied in the vertical direction, and we assume it is positive upwards.</p><pre><code class="language-julia">fi = ForceIntensity(FFlt[0, 0.0, -fmagn, 0, 0, 0]);</code></pre><p>The force loading is now integrated over the &quot;volume&quot; of the integration domain.</p><pre><code class="language-julia">F = CB.distribloads(lfemm, geom0, dchi, fi, 3);

#</code></pre><h2 id="Solve-the-Harmonic-vibration-problem"><a class="docs-heading-anchor" href="#Solve-the-Harmonic-vibration-problem">Solve the Harmonic vibration problem</a><a id="Solve-the-Harmonic-vibration-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-Harmonic-vibration-problem" title="Permalink"></a></h2><p>The frequency sweep will start at <code>fromf</code> and continue through the frequency <code>tof</code>.  The frequencies will be logarithmically distributed throughout this range.</p><pre><code class="language-julia">fromf = 3.0
tof = 70.0
nf = 150
frequencies = logspace(log10(fromf), log10(tof), nf);</code></pre><p>Only a single number per sensor will be collected, the Z direction displacement.</p><pre><code class="language-julia">receptance12 = fill(0.0im, nf)
receptance112 = fill(0.0im, nf)</code></pre><p>Now Loop over</p><pre><code class="language-julia">for   fi in 1:length(frequencies)
    f =  frequencies[fi];
    om = 2*pi*f;</code></pre><p>Solve the system of complex  equations of balance:</p><pre><code class="language-julia">    U = (-om^2*Mt + 1im*om*Ct + Kt) \ F</code></pre><p>Distribute the vector of the solution:</p><pre><code class="language-julia">    scattersysvec!(dchi, U)</code></pre><p>Now sample the solution at the locations of the two sensors, 12 and 112:</p><pre><code class="language-julia">    v = fill(0.0im, 6)
    gathervalues_asvec!(dchi, v, sensors[12])
    p_d = v[1:3];
    receptance12[fi] = p_d[3]/fmagn;
    gathervalues_asvec!(dchi, v, sensors[112])
    p_d = v[1:3];
    receptance112[fi] = p_d[3]/fmagn;
end</code></pre><p>The receptances were calculated above. The mobility and accelerance may be obtained in a postprocessing step.</p><pre><code class="language-julia">oms = (2*pi) .* frequencies;
mobility12 = receptance12 .* (-1im*oms);
mobility112 = receptance112 .* (-1im*oms);
accelerance12 = receptance12 .* (-oms.^2);
accelerance112 = receptance112 .* (-oms.^2);

results = Dict()
results[12] = Dict(&quot;receptance&quot;=&gt;receptance12, &quot;mobility&quot;=&gt;mobility12, &quot;accelerance&quot;=&gt;accelerance12)
results[112] = Dict(&quot;receptance&quot;=&gt;receptance112, &quot;mobility&quot;=&gt;mobility112, &quot;accelerance&quot;=&gt;accelerance112)

#</code></pre><h2 id="Present-the-results-graphically"><a class="docs-heading-anchor" href="#Present-the-results-graphically">Present the results graphically</a><a id="Present-the-results-graphically-1"></a><a class="docs-heading-anchor-permalink" href="#Present-the-results-graphically" title="Permalink"></a></h2><pre><code class="language-julia">using PlotlyJS</code></pre><p>Plot the amplitude of the response curves. We output two curves. The first for the driving-point FRF:</p><pre><code class="language-julia">quantity = &quot;accelerance&quot;; units = &quot;m/s^2/N&quot;
outputat = 12
y = abs.(results[outputat][quantity]) / phun(units)
tc12 = scatter(;x=frequencies, y=y, mode=&quot;lines&quot;, name = &quot;output@$(outputat)&quot;, line_color = &quot;rgb(15, 15, 215)&quot;)</code></pre><p>The second for the cross transfer:</p><pre><code class="language-julia">outputat = 112
y = abs.(results[outputat][quantity]) / phun(units)
tc112 = scatter(;x=frequencies, y=y, mode=&quot;lines&quot;, name = &quot;output@$(outputat)&quot;, line_color = &quot;rgb(215, 15, 15)&quot;)</code></pre><p>Set up the layout:</p><pre><code class="language-julia">layout = Layout(;width=650, height=400, xaxis=attr(title=&quot;Frequency [Hz]&quot;, type = &quot;linear&quot;), yaxis=attr(title=&quot;abs(H) [$(units)]&quot;, type = &quot;log&quot;), title = &quot;Force@$(forceat), $(quantity)&quot;)</code></pre><p>Plot the graphs:</p><pre><code class="language-julia">plots = cat(tc12, tc112; dims = 1)
pl = plot(plots, layout; options = Dict(
        :showSendToCloud=&gt;true,
        :plotlyServerURL=&gt;&quot;https://chart-studio.plotly.com&quot;
        ))
display(pl)</code></pre><p>Plot the phase shift of the response curves. Again we output two curves, the first for the driving-point FRF:</p><pre><code class="language-julia">outputat = 12
y = atan.(imag(results[outputat][quantity]), real(results[outputat][quantity]))/pi*180
tc12 = scatter(;x=frequencies, y=y, mode=&quot;lines&quot;, name = &quot;output@$(outputat)&quot;, line_color = &quot;rgb(15, 15, 215)&quot;)</code></pre><p>The second for the cross transfer:</p><pre><code class="language-julia">outputat = 112
y = atan.(imag(results[outputat][quantity]), real(results[outputat][quantity]))/pi*180
tc112 = scatter(;x=frequencies, y=y, mode=&quot;lines&quot;, name = &quot;output@$(outputat)&quot;, line_color = &quot;rgb(215, 15, 15)&quot;)</code></pre><p>Set up the layout:</p><pre><code class="language-julia">layout = Layout(;width=650, height=400, xaxis=attr(title=&quot;Frequency [Hz]&quot;, type = &quot;linear&quot;), yaxis=attr(title=&quot;Phase shift [deg]&quot;, type = &quot;linear&quot;), title = &quot;Force@$(forceat), $(quantity)&quot;, yaxis_range=[-180, 180])</code></pre><p>Plot the graphs:</p><pre><code class="language-julia">plots = cat(tc12, tc112; dims = 1)
pl = plot(plots, layout; options = Dict(
        :showSendToCloud=&gt;true,
        :plotlyServerURL=&gt;&quot;https://chart-studio.plotly.com&quot;
        ))
display(pl)


true</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 21 August 2020 18:51">Friday 21 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
