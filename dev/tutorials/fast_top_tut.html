<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fast Lagrangian top. · FinEtoolsFlexStructuresTutorials.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">FinEtoolsFlexStructuresTutorials.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="fast_top_tut.html">Fast Lagrangian top.</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="fast_top_tut.html">Fast Lagrangian top.</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtoolsFlexStructuresTutorials.jl/blob/master/docs/src/tutorials/fast_top_tut.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Fast-Lagrangian-top."><a class="docs-heading-anchor" href="#Fast-Lagrangian-top.">Fast Lagrangian top.</a><a id="Fast-Lagrangian-top.-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-Lagrangian-top." title="Permalink"></a></h1><p>Source code: <a href="fast_top_tut.jl"><code>fast_top_tut.jl</code></a></p><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>Fast-spinning Lagrange  top simulated by a beam model. The reference solution is available in Krysl, P., Endres, L.: Explicit Newmark/Verlet algorithm for time integration of the rotational dynamics of rigid bodies. Int. J. Numer. Meth. Eng. 62, 2154–2177 (2005).</p><h2 id="Goals"><a class="docs-heading-anchor" href="#Goals">Goals</a><a id="Goals-1"></a><a class="docs-heading-anchor-permalink" href="#Goals" title="Permalink"></a></h2><ul><li>Illustrate integration of the nonlinear equations of motion with the Newmark algorithm.</li></ul><pre><code class="language-julia hljs">using LinearAlgebra
using PlotlyJS

#</code></pre><h2 id="Definition-of-the-basic-inputs"><a class="docs-heading-anchor" href="#Definition-of-the-basic-inputs">Definition of the basic inputs</a><a id="Definition-of-the-basic-inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-basic-inputs" title="Permalink"></a></h2><p>The finite element code realize on the basic functionality implemented in this package.</p><pre><code class="language-julia hljs">using FinEtools</code></pre><p>The material parameters may be defined with the specification of the units. The elastic properties and the mass density are:</p><pre><code class="language-julia hljs">E = 71240.0 * phun(&quot;MPa&quot;)
nu = 0.31
rho = 2.7e3 * phun(&quot;kg/m^3&quot;)</code></pre><p>The top is a block of square cross-section with dimensions</p><pre><code class="language-julia hljs">Width = 60 * phun(&quot;mm&quot;); Height = 60 * phun(&quot;mm&quot;);
Length = 4*Width

Mass = Width*Height*Length*rho;
IL =  (1/12)*Mass*(Width^2+Height^2);
Ib =  (1/12)*Mass*(Length^2+Height^2)+Mass*(Length/2)^2;
Ih =  (1/12)*Mass*(Width^2+Length^2)+Mass*(Length/2)^2;
Omega0 = 313*pi;
R0 = rotmat3([0.05 0 0]);
g = 9.81 * phun(&quot;m/sec^2&quot;);
q = [0,0,-g*Width*Height*rho];
utol = 1e-3 * phun(&quot;m&quot;);
maxit = 12
dt = min(2*pi/norm(Omega0)/10, 0.005);
tend = 0.8 * phun(&quot;sec&quot;);
ng = 1/2; nb = 1/4*(1/2+ng)^2;</code></pre><p>Choose the mass formulation:</p><pre><code class="language-julia hljs">mass_type=1;


#</code></pre><h2 id="Cross-section"><a class="docs-heading-anchor" href="#Cross-section">Cross-section</a><a id="Cross-section-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-section" title="Permalink"></a></h2><p>Cross-sectional properties are incorporated in the cross-section property. The three arguments supplied are functions. All are returning &quot;constants&quot;. In particular the first two functions each return the dimension of the cross-section as a constant(the beam has a uniform cross-section); the third function defines the orientation of the cross-section in the global Cartesian coordinates. <code>[1.0, 0.0, 0.0]</code> is the vector that together with the tangent to the midline curve of the beam spans the <span>$x_1x_2$</span> plane of the local coordinates for the beam.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.CrossSectionModule: CrossSectionRectangle
cs = CrossSectionRectangle(s -&gt; Width, s -&gt; Width, s -&gt; [1.0, 0.0, 0.0])</code></pre><p>Select the number of elements per leg.</p><pre><code class="language-julia hljs">spin_vector = R0*[0, 0, Omega0];
X=[0 0 0;    reshape(R0*[0,0,Length], 1, 3)];
n=2;
tolerance=Length/n/100;

using FinEtoolsFlexStructures.MeshFrameMemberModule: frame_member
members = []
push!(members, frame_member(X, n, cs))

using FinEtoolsFlexStructures.MeshFrameMemberModule: merge_members
fens, fes = merge_members(members; tolerance = tolerance);</code></pre><p>Material properties</p><pre><code class="language-julia hljs">using FinEtoolsDeforLinear
material = MatDeforElastIso(DeforModelRed3D, rho, E, nu, 0.0)



#</code></pre><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><p>Now we start constructing the discrete finite element model. We begin by constructing the requisite fields, geometry and displacement. These are the so-called &quot;configuration variables&quot;, all initialized to 0. This is that geometry field.</p><pre><code class="language-julia hljs">geom0 = NodalField(fens.xyz)</code></pre><p>This is the displacement field, three unknown displacements per node.</p><pre><code class="language-julia hljs">u0 = NodalField(zeros(size(fens.xyz, 1), 3))</code></pre><p>This is the rotation field, three unknown rotations per node are represented with a rotation matrix, in total nine numbers. The utility function <code>initial_Rfield</code></p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.RotUtilModule: initial_Rfield
Rfield0 = initial_Rfield(fens)</code></pre><p>Finally, this is the displacement and rotation field for incremental changes, incremental displacements and incremental rotations. In total, 6 unknowns per node.</p><pre><code class="language-julia hljs">dchi = NodalField(zeros(size(fens.xyz,1), 6))

#</code></pre><h2 id="Support-conditions"><a class="docs-heading-anchor" href="#Support-conditions">Support conditions</a><a id="Support-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Support-conditions" title="Permalink"></a></h2><p>The &quot;bottom&quot; of the top is pinned.</p><pre><code class="language-julia hljs">box = fill(0.0, 6)
initbox!(box, X[1,:])
supportn = selectnode(fens; box = box, inflate = tolerance)
initbox!(box, X[2,:])
tipn = selectnode(fens; box = box, inflate = tolerance)
for i in [1, 2, 3]
    setebc!(dchi, supportn, true, i)
end
applyebc!(dchi)
numberdofs!(dchi);</code></pre><p>Initial conditions</p><pre><code class="language-julia hljs">v0 = deepcopy(dchi) # need the numbering of the degrees of freedom
for i in 1:size(v0.values, 1)
    v0.values[i, 4:6] = spin_vector
end</code></pre><p>For disambiguation we will refer to the stiffness and mass functions by qualifying them with the corotational-beam module, <code>FEMMCorotBeamModule</code>.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.FEMMCorotBeamModule
CB = FEMMCorotBeamModule
femm = CB.FEMMCorotBeam(IntegDomain(fes, GaussRule(1, 2)), material)
fi = ForceIntensity(q);


using FinEtoolsFlexStructures.RotUtilModule: initial_Rfield, update_rotation_field!
using DelimitedFiles

function integrate(tend, CB, geom0, u0, Rfield0, dchi, v0, report)</code></pre><p>Make sure we don&#39;t clobber any of these variable fields</p><pre><code class="language-julia hljs">    geom0, u0, Rfield0, dchi, v0 = deepcopy((geom0, u0, Rfield0, dchi, v0))</code></pre><p>Additional fields</p><pre><code class="language-julia hljs">    stepdchi = deepcopy(dchi)
    u1 = deepcopy(u0)
    v1 = deepcopy(dchi)
    a1 = deepcopy(dchi) # zero out the Acceleration
    a0 = deepcopy(dchi) # zero out the Acceleration
    Rfield1 = deepcopy(Rfield0)
    v0v = gathersysvec(v0)
    a0v = gathersysvec(a0)
    vpv = gathersysvec(v0);
    dchipv = gathersysvec(dchi);
    stepdchiv = gathersysvec(dchi);
    rhs = gathersysvec(dchi);
    TMPv = deepcopy(rhs)
    utol = 1e-13*dchi.nfreedofs;

    t = 0.0;
    step = 0;
    while (t &lt;= tend)
        t = t + dt;
        (mod(step, 50)==0) &amp;&amp; println(&quot;Time $(t)&quot;); # pause</code></pre><p>Initialization</p><pre><code class="language-julia hljs">        applyebc!(dchi) # Apply boundary conditions
        u1.values[:] = u0.values[:]; # guess
        Rfield1.values[:] = Rfield0.values[:]; # guess
        stepdchi.values[:] .= 0.0;# Total increment in current step
        a1.values[:] = -(1/nb/dt)*v0.values[:] -(1/2-nb)/nb*a0.values[:];
        v1.values[:] = v0.values[:] + dt*((1-ng)*a0.values[:] + ng*a1.values[:]);
        gathersysvec!(v0, v0v)
        gathersysvec!(a0, a0v)
        dchipv = dt*v0v + (dt^2/2*(1-2*nb))*a0v
        vpv = v0v +(dt*(1-ng))*a0v;

        iter = 1;
        while true
            F = CB.distribloads_global(femm, geom0, u1, Rfield1, dchi, fi)
            Fr = CB.restoringforce(femm, geom0, u1, Rfield1, dchi);       # Internal forces
            @. rhs = F + Fr;
            K = CB.stiffness(femm, geom0, u1, Rfield1, dchi);
            M = CB.mass(femm, geom0, u1, Rfield1, dchi);
            G = CB.gyroscopic(femm, geom0, u1, Rfield1, v1, dchi);
            gathersysvec!(stepdchi, stepdchiv)
            @. TMPv = ((-1/(nb*dt^2))*stepdchiv+(1/(nb*dt^2))*dchipv)
            rhs .+= M*TMPv
            @. TMPv = ((-ng/nb/dt)*stepdchiv+(ng/nb/dt)*dchipv - vpv)
            rhs .+= G*TMPv;
            dchi = scattersysvec!(dchi, (K+(ng/nb/dt)*G+(1/(nb*dt^2))*M)\rhs); # Disp. incr
            u1.values[:] += (dchi.values[:,1:3])[:];   # increment displacement
            stepdchi.values[:] += dchi.values[:]
            v1.values[:] += (ng/nb/dt)*dchi.values[:];
            a1.values[:] += (1/nb/dt^2)*dchi.values[:];
            update_rotation_field!(Rfield1, dchi)
            if maximum(abs.(dchi.values[:])) &lt; utol# convergence check
                break;
            end
            if (iter &gt; maxit)# bailout for failed convergence
                error(&quot;Possible failed convergence&quot;);
            end
            iter += 1;
        end
        u0.values[:] = u1.values[:];       # update the displacement
        Rfield0.values[:] = Rfield1.values[:]; # update the rotations
        v0.values[:] = v1.values[:];       # update the velocities
        a0.values[:] = a1.values[:];       # update the accelerations

        report(step, u1, Rfield1)

        step=step+1;
    end
end</code></pre><p>The visualization utilities take advantage of the PlotlyJS library.</p><pre><code class="language-julia hljs">using PlotlyJS
using VisualStructures: plot_space_box, plot_midline, plot_solid, render, react!, default_layout_3d, save_to_json</code></pre><p>Display the graph of the motion of the tip of the top.</p><pre><code class="language-julia hljs">function updategraph(step, u1, Rfield1)
    if (mod(step,20)==0)
        push!(tipx, X[2,1]+u1.values[tipn[1], 1])
        push!(tipy, X[2,2]+u1.values[tipn[1], 2])
        plots = cat(tbox, tref, scatter(;x=tipx./Length, y=tipy./Length, mode=&quot;markers&quot;, name = &quot;Sol&quot;, line_color = &quot;rgb(155, 15, 15)&quot;); dims = 1)
        react!(pl, plots, pl.plot.layout)
        sleep(0.01)
    end
end</code></pre><p>integrate(tend, CB, geom0, u0, Rfield0, dchi, v0, updategraph)</p><pre><code class="language-julia hljs">tipx = Float64[]
tipy = Float64[]
tipz = Float64[]
layout = Layout(; scene=attr(
    xaxis = attr(title=&quot;X&quot;),
    yaxis = attr(title=&quot;Y&quot;),
    zaxis = attr(title=&quot;Z&quot;),
    camera = attr(
        up=attr(x=-0.8, y=-0.6, z=0.07),
        center=attr(x=0.0, y=0.0, z=0.0),
        eye=attr(x=0.1, y=0.12, z=2.17),
        projection = attr(type = &quot;orthographic&quot;)
        )), showlegend = false)
tbox = plot_space_box([[-1.1*Width -1.1*Width 0]; [1.1*Width 1.1*Width 1.1*Length]])
tshape0s = plot_solid(fens, fes; x = geom0.values, u = 0.0.*dchi.values[:, 1:3], R = Rfield0.values, facecolor = &quot;rgb(125, 155, 125)&quot;, opacity = 0.3);
tshape0m = plot_midline(fens, fes; x = geom0.values, u = 0.0.*dchi.values[:, 1:3], color = &quot;rgb(125, 105, 175)&quot;, lwidth = 4)
plots = cat(tbox,  tshape0s, tshape0m; dims = 1)
pl2 = render(plots; layout = layout)
sleep(0.5)

function updateplot(step, u1, Rfield1)
    push!(tipx, X[2,1]+u1.values[tipn[1], 1])
    push!(tipy, X[2,2]+u1.values[tipn[1], 2])
    push!(tipz, X[2,3]+u1.values[tipn[1], 3])
    if (mod(step,13)==0)
        curv = scatter3d(;x=tipx, y=tipy, z=tipz, mode=&quot;lines&quot;, name = &quot;Sol&quot;, line_color = &quot;rgb(155, 15, 15)&quot;)
        tshape1s = plot_solid(fens, fes; x = geom0.values, u = u1.values, R = Rfield1.values, facecolor = &quot;rgb(125, 15, 15)&quot;);
        tshape1m = plot_midline(fens, fes; x = geom0.values, u = u1.values, color = &quot;rgb(125, 15, 15)&quot;, lwidth = 4)
        plots = cat(tbox,  tshape0s, tshape0m,  curv, tshape1s, tshape1m; dims = 1)
        react!(pl2, plots, pl2.plot.layout)
        sleep(0.12)
    end
end


integrate(4.5*tend, CB, geom0, u0, Rfield0, dchi, v0, updateplot)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 13 January 2022 22:35">Thursday 13 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
