<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modal analysis of a free-floating steel circle · FinEtoolsFlexStructuresTutorials.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">FinEtoolsFlexStructuresTutorials.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="circle_modal_tut.html">Modal analysis of a free-floating steel circle</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="circle_modal_tut.html">Modal analysis of a free-floating steel circle</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtoolsFlexStructuresTutorials.jl/blob/master/docs/src/tutorials/circle_modal_tut.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modal-analysis-of-a-free-floating-steel-circle"><a class="docs-heading-anchor" href="#Modal-analysis-of-a-free-floating-steel-circle">Modal analysis of a free-floating steel circle</a><a id="Modal-analysis-of-a-free-floating-steel-circle-1"></a><a class="docs-heading-anchor-permalink" href="#Modal-analysis-of-a-free-floating-steel-circle" title="Permalink"></a></h1><p>Source code: <a href="circle_modal_tut.jl"><code>circle_modal_tut.jl</code></a></p><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>Vibration analysis of a beam simply supported in one plane, and clamped in another. The results are compared with analytical expressions. This is a benchmark from the NAFEMS Selected Benchmarks for Natural Frequency Analysis, publication: Test VM09: Circular Ring –  In-plane and Out-of-plane Vibration.</p><h2 id="Reference-frequencies"><a class="docs-heading-anchor" href="#Reference-frequencies">Reference frequencies</a><a id="Reference-frequencies-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-frequencies" title="Permalink"></a></h2><p>There will be 6 rigid body modes (zero natural frequencies).</p><p>The numerical results are due to the publication: NAFEMS Finite Element Methods &amp; Standards, Abbassian, F., Dawswell, D. J., and Knowles, N. C. Selected Benchmarks for Natural Frequency Analysis, Test No.</p><ol><li>Glasgow: NAFEMS, Nov., 1987.</li></ol><p>The reference values were analytically determined (Blevins, FORMULAS FOR DYNAMICS, ACOUSTICS AND VIBRATION, Table 4.16). Note that shear flexibility was neglected when computing the reference values.</p><table><tr><th style="text-align: right">Mode</th><th style="text-align: right">Reference Value (Hz)</th><th style="text-align: right">NAFEMS Target Value (Hz)</th></tr><tr><td style="text-align: right">7, 8</td><td style="text-align: right">(out of plane)</td><td style="text-align: right">51.85</td></tr><tr><td style="text-align: right">9, 10</td><td style="text-align: right">(in plane)</td><td style="text-align: right">53.38</td></tr><tr><td style="text-align: right">11, 12</td><td style="text-align: right">(out of plane)</td><td style="text-align: right">148.8</td></tr><tr><td style="text-align: right">13, 14</td><td style="text-align: right">(in plane)</td><td style="text-align: right">151.0</td></tr><tr><td style="text-align: right">15, 16</td><td style="text-align: right">(out of plane)</td><td style="text-align: right">287.0</td></tr><tr><td style="text-align: right">17, 18</td><td style="text-align: right">(in plane)</td><td style="text-align: right">289.5</td></tr></table><h2 id="Goals"><a class="docs-heading-anchor" href="#Goals">Goals</a><a id="Goals-1"></a><a class="docs-heading-anchor-permalink" href="#Goals" title="Permalink"></a></h2><ul><li>Show convergence relative to reference values.</li><li>Demonstrate the optimization of eigenvalue accuracy by choosing mass type.</li></ul><pre><code class="language-julia hljs">#</code></pre><h2 id="Definition-of-the-basic-inputs"><a class="docs-heading-anchor" href="#Definition-of-the-basic-inputs">Definition of the basic inputs</a><a id="Definition-of-the-basic-inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-basic-inputs" title="Permalink"></a></h2><p>The finite element code realize on the basic functionality implemented in this package.</p><pre><code class="language-julia hljs">using FinEtools</code></pre><p>The material parameters may be defined with the specification of the units. The elastic properties are:</p><pre><code class="language-julia hljs">E = 200.0 * phun(&quot;GPa&quot;)
nu = 0.3;</code></pre><p>The mass density is</p><pre><code class="language-julia hljs">rho = 8000 * phun(&quot;kg/m^3&quot;)</code></pre><p>Here are the cross-sectional dimensions and the length of the beam between supports.</p><pre><code class="language-julia hljs">radius = 1.0 * phun(&quot;m&quot;); diameter = 0.1 * phun(&quot;m&quot;);

#</code></pre><h2 id="Cross-section"><a class="docs-heading-anchor" href="#Cross-section">Cross-section</a><a id="Cross-section-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-section" title="Permalink"></a></h2><p>Cross-sectional properties are incorporated in the cross-section property. The three arguments supplied are functions. All are returning &quot;constants&quot;. In particular the first two functions each return the dimension of the cross-section as a constant(the beam has a uniform cross-section); the third function defines the orientation of the cross-section in the global Cartesian coordinates. <code>[1.0, 0.0, 0.0]</code> is the vector that together with the tangent to the midline curve of the beam spans the <span>$x_1x_2$</span> plane of the local coordinates for the beam.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.CrossSectionModule: CrossSectionCircle
cs = CrossSectionCircle(s -&gt; diameter/2, s -&gt; [1.0, 0.0, 0.0])
@show cs.parameters(0.0)</code></pre><p>For instance the the first out of plane mode is listed in the reference cited above as</p><pre><code class="language-julia hljs">R = radius
I = cs.parameters(0.0)[4]
m = rho * cs.parameters(0.0)[1]
J = cs.parameters(0.0)[2]
G = E/2/(1+nu)
i = 2 # the first non-rigid body mode
@show i*(i^2-1)/(2*pi*R^2)*sqrt(E*I/m/(i^2+E*I/G/J))</code></pre><p>The first &quot;ovaling&quot; (in-plane) mode is:</p><pre><code class="language-julia hljs">i = 2 # the first ovaling mode
@show i*(i^2-1)/(2*pi*R^2*(i^2+1)^(1/2))*sqrt(E*I/m)</code></pre><p>The purpose of the numerical model is to calculate approximation to the reference frequencies.</p><pre><code class="language-julia hljs">neigvs = 18;</code></pre><p>We will generate</p><pre><code class="language-julia hljs">n = 20</code></pre><p>beam elements along the member.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.MeshFrameMemberModule: frame_member
tolerance = radius/n/1000;
fens, fes = frame_member([0 0 0; 2*pi 0 0], n, cs)
for i in 1:count(fens)
    a = fens.xyz[i, 1]
    fens.xyz[i, :] .= (radius+radius*cos(a), radius*sin(a), 0)
end
fens, fes = mergenodes(fens, fes, tolerance, [1, n+1])

#</code></pre><h2 id="Material"><a class="docs-heading-anchor" href="#Material">Material</a><a id="Material-1"></a><a class="docs-heading-anchor-permalink" href="#Material" title="Permalink"></a></h2><p>Material properties can be now used to create a material: isotropic elasticity model of the <code>FinEtoolsDeforLinear</code> package is instantiated.</p><pre><code class="language-julia hljs">using FinEtoolsDeforLinear
material = MatDeforElastIso(DeforModelRed3D, rho, E, nu, 0.0)

#</code></pre><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><p>Now we start constructing the discrete finite element model. We begin by constructing the requisite fields, geometry and displacement. These are the so-called &quot;configuration variables&quot;, all initialized to 0. This is that geometry field.</p><pre><code class="language-julia hljs">geom0 = NodalField(fens.xyz)</code></pre><p>This is the displacement field, three unknown displacements per node.</p><pre><code class="language-julia hljs">u0 = NodalField(zeros(size(fens.xyz, 1), 3))</code></pre><p>This is the rotation field, three unknown rotations per node are represented with a rotation matrix, in total nine numbers. The utility function <code>initial_Rfield</code></p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.RotUtilModule: initial_Rfield
Rfield0 = initial_Rfield(fens)</code></pre><p>Here we verify the number of nodes and the number of degrees of freedom in the rotation field per node.</p><pre><code class="language-julia hljs">@show nents(Rfield0)
@show ndofs(Rfield0)</code></pre><p>Finally, this is the displacement and rotation field for incremental changes, incremental displacements and incremental rotations. In total, 6 unknowns per node.</p><pre><code class="language-julia hljs">dchi = NodalField(zeros(size(fens.xyz, 1), 6))</code></pre><p>There are no support conditions.</p><pre><code class="language-julia hljs">applyebc!(dchi)</code></pre><p>The  the number of free (unknown) degrees of freedom is equal to the total number of degrees of freedom in the system.</p><pre><code class="language-julia hljs">numberdofs!(dchi);


#</code></pre><h2 id="Assemble-the-global-discrete-system"><a class="docs-heading-anchor" href="#Assemble-the-global-discrete-system">Assemble the global discrete system</a><a id="Assemble-the-global-discrete-system-1"></a><a class="docs-heading-anchor-permalink" href="#Assemble-the-global-discrete-system" title="Permalink"></a></h2><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.FEMMCorotBeamModule: FEMMCorotBeam
femm = FEMMCorotBeam(IntegDomain(fes, GaussRule(1, 2)), material);</code></pre><p>For disambiguation we will refer to the stiffness and mass functions by qualifying them with the corotational-beam module, <code>FEMMCorotBeamModule</code>.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.FEMMCorotBeamModule
CB = FEMMCorotBeamModule</code></pre><p>Thus we can construct the stiffness and mass matrix as follows: Note that the finite element machine is the first argument. This provides access to the integration domain. The next argument is the geometry field, followed by the displacement, rotations, and incremental displacement/rotation fields.</p><pre><code class="language-julia hljs">K = CB.stiffness(femm, geom0, u0, Rfield0, dchi);
M = CB.mass(femm, geom0, u0, Rfield0, dchi);</code></pre><p>We can compare the size of the stiffness matrix with the number of degrees of freedom that are unknown (20).</p><pre><code class="language-julia hljs">@show size(K)

#</code></pre><h2 id="Solve-the-free-vibration-problem"><a class="docs-heading-anchor" href="#Solve-the-free-vibration-problem">Solve the free-vibration problem</a><a id="Solve-the-free-vibration-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-free-vibration-problem" title="Permalink"></a></h2><pre><code class="language-julia hljs">oshift = (2*pi*15)^2</code></pre><p>The Arnoldi algorithm implemented in the well-known <code>Arpack</code> package is used to solve the generalized eigenvalue problem with the sparse matrices. As is common in structural dynamics, we request the smallest eigenvalues in absolute value (<code>:SM</code>).</p><pre><code class="language-julia hljs">using Arpack
evals, evecs, nconv = eigs(Symmetric(K + oshift * M), Symmetric(M); nev=neigvs, which=:SM, explicittransform = :none);</code></pre><p>First  we should check that the requested eigenvalues actually converged:</p><pre><code class="language-julia hljs">@show nconv == neigvs</code></pre><p>Make sure the eigenvalues and eigenvectors are stripped of the imaginary part.</p><pre><code class="language-julia hljs">evals = real.(evals)
evecs = real.(evecs)</code></pre><p>The eigenvalues (i. e. the squares of the angular frequencies) are returned in the vector <code>evals</code>. The mode shapes constitute the columns of the matrix <code>evecs</code>.</p><pre><code class="language-julia hljs">@show size(evecs)</code></pre><p>The natural frequencies are obtained from the squares of the angular frequencies. We note the use of <code>sqrt.</code> which broadcast the square root over the array <code>evals</code>.</p><pre><code class="language-julia hljs">fs = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);

#</code></pre><h2 id="Comparison-of-computed-and-analytical-results"><a class="docs-heading-anchor" href="#Comparison-of-computed-and-analytical-results">Comparison of computed and analytical results</a><a id="Comparison-of-computed-and-analytical-results-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-computed-and-analytical-results" title="Permalink"></a></h2><p>The approximate and analytical frequencies are now reported.</p><pre><code class="language-julia hljs">sigdig(n) = round(n * 10000) / 10000
println(&quot;Approximate frequencies: $(sigdig.(fs)) [Hz]&quot;)

#</code></pre><h2 id="Set-up-the-visualization-of-the-vibration-modes"><a class="docs-heading-anchor" href="#Set-up-the-visualization-of-the-vibration-modes">Set up the visualization of the vibration modes</a><a id="Set-up-the-visualization-of-the-vibration-modes-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-visualization-of-the-vibration-modes" title="Permalink"></a></h2><p>The animation will show one of the vibration modes overlaid on the undeformed geometry. The configuration during the animation needs to reflect rotations. The function <code>update_rotation_field!</code> will update the rotation field given a vibration mode.</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.RotUtilModule: update_rotation_field!</code></pre><p>The visualization utilities take advantage of the PlotlyJS library.</p><pre><code class="language-julia hljs">using PlotlyJS
using VisualStructures: plot_space_box, plot_solid, render, react!, default_layout_3d, save_to_json</code></pre><p>The magnitude of the vibration modes (displacements  and rotations) will be amplified with this scale factor:</p><pre><code class="language-julia hljs">scale = 1.5</code></pre><p>In order to handle variables inside loops correctly, we create a local scope with the <code>let end</code> block.</p><pre><code class="language-julia hljs">vis(mode) = let</code></pre><p>The extents of the box will be preserved during animation in order to eliminate changes in the viewing parameters.</p><pre><code class="language-julia hljs">    tbox = plot_space_box(reshape(inflatebox!(boundingbox(fens.xyz), 0.3 * radius), 2, 3))</code></pre><p>This is the geometry of the structure without deformation (undeformed). It is displayed as gray, partially transparent.</p><pre><code class="language-julia hljs">    tenv0 = plot_solid(fens, fes; x=geom0.values, u=0.0 .* dchi.values[:, 1:3], R=Rfield0.values, facecolor=&quot;rgb(125, 155, 125)&quot;, opacity=0.3);</code></pre><p>Initially the plot consists of the box and the undeformed geometry.</p><pre><code class="language-julia hljs">    plots = cat(tbox, tenv0; dims=1)</code></pre><p>Create the layout for the plot. Set the size of the window.</p><pre><code class="language-julia hljs">    layout = default_layout_3d(;width=600, height=600)</code></pre><p>Set the aspect mode to get the correct proportions.</p><pre><code class="language-julia hljs">    layout[:scene][:aspectmode] = &quot;data&quot;</code></pre><p>Render the undeformed structure</p><pre><code class="language-julia hljs">    pl = render(plots; layout=layout, title=&quot;Mode $(mode)&quot;)
    sleep(2.115)</code></pre><p>This is the animation loop.</p><ol><li>Distribute a fraction of the selected eigenvector into the incremental displacement/rotation field.</li><li>Create the deformed configuration by defining displacement field <code>u1</code> and rotation field <code>Rfield1</code>.</li><li>Create the plot for the deformed configuration, and add it to the list of plots.</li><li>Call the <code>react!</code> function to update the display. Sleep for a brief period of time to give the display a chance to become current.</li></ol><pre><code class="language-julia hljs">    for xscale in scale .* sin.(collect(0:1:89) .* (2 * pi / 21))
        scattersysvec!(dchi, xscale .* evecs[:, mode])
        u1 = deepcopy(u0)
        u1.values .= dchi.values[:, 1:3]
        Rfield1 = deepcopy(Rfield0)
        update_rotation_field!(Rfield1, dchi)
        tenv1 = plot_solid(fens, fes; x=geom0.values, u=dchi.values[:, 1:3], R=Rfield1.values, facecolor=&quot;rgb(50, 55, 125)&quot;);
        plots = cat(tbox, tenv0, tenv1; dims=1)
        react!(pl, plots, pl.plot.layout)
        sleep(0.115)
    end
end

#</code></pre><h2 id="Visualize-vibration-mode"><a class="docs-heading-anchor" href="#Visualize-vibration-mode">Visualize vibration mode</a><a id="Visualize-vibration-mode-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-vibration-mode" title="Permalink"></a></h2><p>Animate the harmonic motion of the mode given as argument: vis(7)</p><pre><code class="language-julia hljs">using FinEtoolsFlexStructures.FESetCorotBeamModule: MASS_TYPE_CONSISTENT_NO_ROTATION_INERTIA,
MASS_TYPE_CONSISTENT_WITH_ROTATION_INERTIA,
MASS_TYPE_LUMPED_DIAGONAL_NO_ROTATION_INERTIA,
MASS_TYPE_LUMPED_DIAGONAL_WITH_ROTATION_INERTIA

results = let
    results = Dict()
    for mtype in [
        MASS_TYPE_CONSISTENT_NO_ROTATION_INERTIA,
        MASS_TYPE_CONSISTENT_WITH_ROTATION_INERTIA,
        MASS_TYPE_LUMPED_DIAGONAL_NO_ROTATION_INERTIA,
        MASS_TYPE_LUMPED_DIAGONAL_WITH_ROTATION_INERTIA]
        M = CB.mass(femm, geom0, u0, Rfield0, dchi; mass_type = mtype);

        evals, evecs, nconv = eigs(Symmetric(K + oshift * M), Symmetric(M); nev=neigvs, which=:SM, explicittransform = :none);
        evals = real.(evals)
        evecs = real.(evecs)
        results[mtype] = evals, evecs
    end
    results
end

colors = [
&quot;rgb(125, 15, 15)&quot;,
&quot;rgb(15, 155, 15)&quot;,
&quot;rgb(15, 15, 155)&quot;,
&quot;rgb(125, 115, 115)&quot;
]

evals = results[MASS_TYPE_CONSISTENT_NO_ROTATION_INERTIA][1]
x = 1:length(evals); y = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);
tc0 = scatter(;x=x, y=y, mode=&quot;markers&quot;, name = &quot;cons, wo&quot;, line_color = &quot;rgb(215, 15, 15)&quot;, marker = attr(size = 9, symbol = &quot;diamond-open&quot;))
evals = results[MASS_TYPE_CONSISTENT_WITH_ROTATION_INERTIA][1]
x = 1:length(evals); y = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);
tc1 = scatter(;x=x, y=y, mode=&quot;markers&quot;, name = &quot;cons, w&quot;, line_color = &quot;rgb(15, 215, 15)&quot;, marker = attr(size = 9, symbol = &quot;triangle-down&quot;))
evals = results[MASS_TYPE_LUMPED_DIAGONAL_NO_ROTATION_INERTIA][1]
x = 1:length(evals); y = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);
tc2 = scatter(;x=x, y=y, mode=&quot;markers&quot;, name = &quot;lumped, wo&quot;, line_color = &quot;rgb(15, 15, 215)&quot;, marker = attr(size = 9, symbol = &quot;x-open&quot;))
evals = results[MASS_TYPE_LUMPED_DIAGONAL_WITH_ROTATION_INERTIA][1]
x = 1:length(evals); y = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);
tc3 = scatter(;x=x, y=y, mode=&quot;markers&quot;, name = &quot;lumped, w&quot;, line_color = &quot;rgb(165, 165, 15)&quot;, marker = attr(size = 9, symbol = &quot;square&quot;))</code></pre><p>7, 8 (out of plane)         51.85                 52.29 9, 10 (in plane)            53.38                 53.97 11, 12 (out of plane)      148.8                 149.7 13, 14 (in plane)          151.0                 152.4 15, 16 (out of plane)      287.0                 288.3 17, 18 (in plane)          289.5                 288.3</p><pre><code class="language-julia hljs">rfs = vec(Float64[0 0 0 0 0 0 51.85 51.85 53.38 53.38 148.8 148.8 151.0 151.0 287.0 287.0 289.5 289.5])

rtc = scatter(;x=collect(1:length(rfs)), y=rfs, mode=&quot;lines&quot;, name = &quot;ref&quot;, line_color = &quot;rgb(15, 15, 15)&quot;)</code></pre><p>Set up the layout:</p><pre><code class="language-julia hljs">layout = Layout(;xaxis=attr(title=&quot;Mode&quot;, type = &quot;linear&quot;), yaxis=attr(title=&quot;Frequency [hertz]&quot;, type = &quot;linear&quot;), title = &quot;Comparison of mass types&quot;)</code></pre><p>Plot the graphs:</p><pre><code class="language-julia hljs">config  = PlotConfig(plotlyServerURL=&quot;https://chart-studio.plotly.com&quot;, showLink=true)
pl = plot([rtc, tc0, tc1, tc2, tc3], layout; config = config)
display(pl)


#</code></pre><h2 id="&quot;Mixed&quot;-mass-matrix"><a class="docs-heading-anchor" href="#&quot;Mixed&quot;-mass-matrix">&quot;Mixed&quot; mass matrix</a><a id="&quot;Mixed&quot;-mass-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;Mixed&quot;-mass-matrix" title="Permalink"></a></h2><p>As the graph suggests we can try mixing together mass matrices computed from different assumptions (lumped versus consistent, with or without rotation inertia). No particular justification can be provided for these numbers other than best low-frequency matching for linear bars suggests that 50% can be taken lumped and 50% consistent. Here it is obviously more complicated due to the presence of rotation inertia.</p><pre><code class="language-julia hljs">M = 0.5 .* CB.mass(femm, geom0, u0, Rfield0, dchi; mass_type = MASS_TYPE_LUMPED_DIAGONAL_NO_ROTATION_INERTIA) +
    0.5 .* CB.mass(femm, geom0, u0, Rfield0, dchi; mass_type = MASS_TYPE_CONSISTENT_WITH_ROTATION_INERTIA);</code></pre><p>With this mixed mass matrix we solve the free vibration problem again.</p><pre><code class="language-julia hljs">evals, evecs, nconv = eigs(Symmetric(K + oshift * M), Symmetric(M); nev=neigvs, which=:SM, explicittransform = :none);</code></pre><p>Plotting the newly obtained data on top of the previously presented data, we can observe sometimes substantial improvement of accuracy of the mixed-matrix formulation relative to the individual mass matrix types.</p><pre><code class="language-julia hljs">x = 1:length(evals); y = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);
mtc = scatter(;x=x, y=y, mode=&quot;markers&quot;, name = &quot;mixed&quot;, line_color = &quot;rgb(215, 15, 215)&quot;, marker = attr(size = 9, symbol = &quot;circle&quot;))
config  = PlotConfig(plotlyServerURL=&quot;https://chart-studio.plotly.com&quot;, showLink=true)
pl = plot([rtc, tc0, tc1, tc2, tc3, mtc], layout; config = config)
display(pl)

nothing</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 13 January 2022 22:21">Thursday 13 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
